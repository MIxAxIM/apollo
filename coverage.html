
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>apollo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Salvionied/apollo/ApolloBuilder.go (73.0%)</option>
				
				<option value="file1">github.com/Salvionied/apollo/Models.go (69.6%)</option>
				
				<option value="file2">github.com/Salvionied/apollo/Utils.go (100.0%)</option>
				
				<option value="file3">github.com/Salvionied/apollo/backends.go (14.3%)</option>
				
				<option value="file4">github.com/Salvionied/apollo/plutusencoder/plutus.go (82.6%)</option>
				
				<option value="file5">github.com/Salvionied/apollo/serialization/Address/Address.go (97.5%)</option>
				
				<option value="file6">github.com/Salvionied/apollo/serialization/Amount/Amount.go (100.0%)</option>
				
				<option value="file7">github.com/Salvionied/apollo/serialization/Asset/Asset.go (100.0%)</option>
				
				<option value="file8">github.com/Salvionied/apollo/serialization/AssetName/AssetName.go (100.0%)</option>
				
				<option value="file9">github.com/Salvionied/apollo/serialization/HDWallet/HDWallet.go (78.3%)</option>
				
				<option value="file10">github.com/Salvionied/apollo/serialization/Key/Key.go (80.3%)</option>
				
				<option value="file11">github.com/Salvionied/apollo/serialization/Metadata/Metadata.go (89.3%)</option>
				
				<option value="file12">github.com/Salvionied/apollo/serialization/MultiAsset/MultiAsset.go (94.3%)</option>
				
				<option value="file13">github.com/Salvionied/apollo/serialization/NativeScript/NativeScript.go (90.9%)</option>
				
				<option value="file14">github.com/Salvionied/apollo/serialization/PlutusData/PlutusData.go (22.6%)</option>
				
				<option value="file15">github.com/Salvionied/apollo/serialization/Policy/Policy.go (60.0%)</option>
				
				<option value="file16">github.com/Salvionied/apollo/serialization/Redeemer/Redeemer.go (100.0%)</option>
				
				<option value="file17">github.com/Salvionied/apollo/serialization/Transaction/Transaction.go (83.3%)</option>
				
				<option value="file18">github.com/Salvionied/apollo/serialization/TransactionBody/TransactionBody.go (71.4%)</option>
				
				<option value="file19">github.com/Salvionied/apollo/serialization/TransactionInput/TransactionInput.go (100.0%)</option>
				
				<option value="file20">github.com/Salvionied/apollo/serialization/TransactionOutput/TransactionOutput.go (84.2%)</option>
				
				<option value="file21">github.com/Salvionied/apollo/serialization/TransactionWitnessSet/TransactionWitnessSet.go (66.7%)</option>
				
				<option value="file22">github.com/Salvionied/apollo/serialization/UTxO/UTxO.go (100.0%)</option>
				
				<option value="file23">github.com/Salvionied/apollo/serialization/Value/Value.go (83.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apollo

import (
        "crypto/ed25519"
        "encoding/hex"
        "errors"
        "fmt"
        "strconv"

        "github.com/Salvionied/apollo/apollotypes"
        "github.com/Salvionied/apollo/constants"
        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Amount"
        "github.com/Salvionied/apollo/serialization/Certificate"
        "github.com/Salvionied/apollo/serialization/HDWallet"
        "github.com/Salvionied/apollo/serialization/Key"
        "github.com/Salvionied/apollo/serialization/Metadata"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/NativeScript"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionBody"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/TransactionWitnessSet"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/serialization/Value"
        "github.com/Salvionied/apollo/serialization/VerificationKeyWitness"
        "github.com/Salvionied/apollo/serialization/Withdrawal"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/Salvionied/apollo/txBuilding/Backend/BlockFrostChainContext"
        "github.com/Salvionied/apollo/txBuilding/Utils"
        "github.com/fxamacker/cbor/v2"
        "golang.org/x/exp/slices"
)

const (
        EX_MEMORY_BUFFER = 0.2
        EX_STEP_BUFFER   = 0.2
)

type Apollo struct {
        Context            Base.ChainContext
        payments           []PaymentI
        isEstimateRequired bool
        auxiliaryData      *Metadata.AuxiliaryData
        utxos              []UTxO.UTxO
        preselectedUtxos   []UTxO.UTxO
        inputAddresses     []Address.Address
        tx                 *Transaction.Transaction
        datums             []PlutusData.PlutusData
        requiredSigners    []serialization.PubKeyHash
        v1scripts          []PlutusData.PlutusV1Script
        v2scripts          []PlutusData.PlutusV2Script
        redeemers          []Redeemer.Redeemer
        redeemersToUTxO    map[string]Redeemer.Redeemer
        stakeRedeemers     map[string]Redeemer.Redeemer
        mintRedeemers      map[string]Redeemer.Redeemer
        mint               []Unit
        collaterals        []UTxO.UTxO
        Fee                int64
        FeePadding         int64
        Ttl                int64
        ValidityStart      int64
        totalCollateral    int
        referenceInputs    []TransactionInput.TransactionInput
        collateralReturn   *TransactionOutput.TransactionOutput
        withdrawals        *Withdrawal.Withdrawal
        certificates       *Certificate.Certificates
        nativescripts      []NativeScript.NativeScript
        usedUtxos          []string
        referenceScripts   []PlutusData.ScriptHashable
        wallet             apollotypes.Wallet
        scriptHashes       []string
}

/*
*

        New creates and initializes a new Apollo instance with the specified chain context,
        in which sets up various internal data structures for building and handling transactions.

        Params:
                cc (Base.ChainContext): The chain context to use for transaction building.

        Returns:
                *Apollo: A pointer to the initialized Apollo instance.
*/
func New(cc Base.ChainContext) *Apollo <span class="cov8" title="1">{
        return &amp;Apollo{
                Context:            cc,
                payments:           []PaymentI{},
                isEstimateRequired: false,
                auxiliaryData:      &amp;Metadata.AuxiliaryData{},
                utxos:              []UTxO.UTxO{},
                preselectedUtxos:   []UTxO.UTxO{},
                inputAddresses:     []Address.Address{},
                tx:                 nil,
                datums:             make([]PlutusData.PlutusData, 0),
                requiredSigners:    make([]serialization.PubKeyHash, 0),
                v1scripts:          make([]PlutusData.PlutusV1Script, 0),
                v2scripts:          make([]PlutusData.PlutusV2Script, 0),
                redeemers:          make([]Redeemer.Redeemer, 0),
                redeemersToUTxO:    make(map[string]Redeemer.Redeemer),
                stakeRedeemers:     make(map[string]Redeemer.Redeemer),
                mint:               make([]Unit, 0),
                collaterals:        make([]UTxO.UTxO, 0),
                Fee:                0,
                FeePadding:         0,
                usedUtxos:          make([]string, 0),
                referenceInputs:    make([]TransactionInput.TransactionInput, 0),
                referenceScripts:   make([]PlutusData.ScriptHashable, 0),
                mintRedeemers:      make(map[string]Redeemer.Redeemer)}
}</span>

/*
*

        GetWallet returns the wallet associated with the Apollo instance.

        Returns:
                apollotypes.Wallet: The wallet associated with the Apollo instance.
*/
func (b *Apollo) GetWallet() apollotypes.Wallet <span class="cov8" title="1">{
        return b.wallet
}</span>

/*
*

        AddInput appends one or more UTxOs to the list of preselected
        UTxOs for transaction inputs.

        Params:
                utxos (...UTxO.UTxO): A set of UTxOs to be added as inputs.

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) AddInput(utxos ...UTxO.UTxO) *Apollo <span class="cov8" title="1">{
        b.preselectedUtxos = append(b.preselectedUtxos, utxos...)
        return b
}</span>

/*
*

        ConsumeUTxO adds a UTxO as an input to the transaction and deducts the specified payments from it.

        Params:
                utxo (UTxO.UTxO): The UTxO to be consumed as an input.
                payments (...PaymentI): A sett of payments to be deducted from the UTxO.

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) ConsumeUTxO(utxo UTxO.UTxO, payments ...PaymentI) *Apollo <span class="cov8" title="1">{
        b.preselectedUtxos = append(b.preselectedUtxos, utxo)
        selectedValue := utxo.Output.GetAmount()
        for _, payment := range payments </span><span class="cov8" title="1">{
                selectedValue = selectedValue.Sub(payment.ToValue())
        }</span>
        <span class="cov8" title="1">if selectedValue.Less(Value.Value{}) </span><span class="cov0" title="0">{
                panic("selected value is negative")</span>
        }
        <span class="cov8" title="1">b.payments = append(b.payments, payments...)
        selectedValue = selectedValue.RemoveZeroAssets()
        p := NewPaymentFromValue(utxo.Output.GetAddress(), selectedValue)
        b.payments = append(b.payments, p)
        return b</span>
}

/*
*

                ConsumeAssetsFromUtxo adds a UTxO as an input to the transaction and deducts the specified asset payments from it.

                 Params:
                           utxo (UTxO.UTxO): The UTxO to be consumed as an input.
                           payments (...PaymentI): Asset payments to be deducted from the UTxO.

                 Returns:
                           *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) ConsumeAssetsFromUtxo(utxo UTxO.UTxO, payments ...PaymentI) *Apollo <span class="cov8" title="1">{
        b.preselectedUtxos = append(b.preselectedUtxos, utxo)
        selectedValue := utxo.Output.GetAmount()
        for _, payment := range payments </span><span class="cov8" title="1">{
                selectedValue = selectedValue.Sub(Value.SimpleValue(0, payment.ToValue().GetAssets()))
        }</span>
        <span class="cov8" title="1">if selectedValue.Less(Value.Value{}) </span><span class="cov0" title="0">{
                panic("selected value is negative")</span>
                <span class="cov0" title="0">return b</span>
        }
        <span class="cov8" title="1">b.payments = append(b.payments, payments...)
        selectedValue = selectedValue.RemoveZeroAssets()
        p := NewPaymentFromValue(utxo.Output.GetAddress(), selectedValue)
        b.payments = append(b.payments, p)
        return b</span>
}

/*
*

        AddLoadedUTxOs appends one or more UTxOs to the list of loaded UTxOs.

        Params:
                utxos (...UTxO.UTxO): A set of UTxOs to be added to the loaded UTxOs.

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) AddLoadedUTxOs(utxos ...UTxO.UTxO) *Apollo <span class="cov8" title="1">{
        b.utxos = append(b.utxos, utxos...)
        return b
}</span>

/*
*

        AddInputAddress appends an input address to the list of input addresses for the transaction.

        Params:
                address (Address.Address): The input address to be added.

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) AddInputAddress(address Address.Address) *Apollo <span class="cov0" title="0">{
        b.inputAddresses = append(b.inputAddresses, address)
        return b

}</span>

/*
*

        AddInputAddressFromBech32 decodes a Bech32 address and
        appends it to the list of input addresses for the transaction.

        Params:
                address (string): The Bech32 address to be decoded and added

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) AddInputAddressFromBech32(address string) *Apollo <span class="cov8" title="1">{
        decoded_addr, _ := Address.DecodeAddress(address)
        b.inputAddresses = append(b.inputAddresses, decoded_addr)
        return b
}</span>

/*
*

        AddPayment appends a payment to the list of payments for the transaction.

        Params:
                payment (PaymentI): The payment to be added.

        Returns:
                *Apollo: A pointer to the modified Apollo instance with the payment added.
*/
func (b *Apollo) AddPayment(payment PaymentI) *Apollo <span class="cov8" title="1">{
        b.payments = append(b.payments, payment)
        return b
}</span>

/*
*

        PayToAddressBech32 creates a payment to the specified Bech32 address
        with the given lovelace and units.

        Params:
                address (string): The Bech32 address to which the payment will be made.
                lovelace (int): The amount in lovelace to be paid.
                units (...Unit): The units (assets) to be paid along with the lovelace.

        Returns:
                *Apollo: A pointer to the modified Apollo instance with the payment added.
*/
func (b *Apollo) PayToAddressBech32(address string, lovelace int, units ...Unit) *Apollo <span class="cov8" title="1">{
        decoded_addr, _ := Address.DecodeAddress(address)
        return b.AddPayment(&amp;Payment{lovelace, decoded_addr, units, nil, nil, false})
}</span>

/*
*

                PayToAddress creates a payment to the specified address with the given lovelace and units,
                then adds it to the list of payment.

                Params:
                        address (Address.Address): The recipient's address for the payment.
                           lovelace (int): The amount in lovelace to send in the payment.
                           units (...Unit): A set of units to include in the payment.

                Returns:
                        *Apollo: A pointer to the modified Apollo instance with the payment added.
*/
func (b *Apollo) PayToAddress(address Address.Address, lovelace int, units ...Unit) *Apollo <span class="cov8" title="1">{
        return b.AddPayment(&amp;Payment{lovelace, address, units, nil, nil, false})
}</span>

/*
*

                AddDatum appends a Plutus datum to the list of data associated with the Apollo instance.

                Params:
                           pd (*PlutusData.PlutusData): The Plutus datum to be added.

                Returns:
                           *Apollo: A pointer to the modified Apollo instance with the datum added.
*/
func (b *Apollo) AddDatum(pd *PlutusData.PlutusData) *Apollo <span class="cov8" title="1">{
        b.datums = append(b.datums, *pd)
        return b
}</span>

/*
*

                PayToContract creates a payment to a smart contract address and includes a Plutus datum, which
                 is added to the list of payments, and if a datum is provided, it is added to the data list.

                Params:
                contractAddress (Address.Address): The smart contract address to send the payment to.
                pd (*PlutusData.PlutusData): Plutus datum to include in the payment.
                lovelace (int): The amount in lovelace to send in the payment.
                isInline (bool): Indicates if the payment is inline with the datum.
                units (...Unit): A set of units to include in the payment.

                Returns:
                        *Apollo: A pointer to the modified Apollo instance with the payment and datum added.
*/
func (b *Apollo) PayToContract(contractAddress Address.Address, pd *PlutusData.PlutusData, lovelace int, isInline bool, units ...Unit) *Apollo <span class="cov8" title="1">{
        if isInline </span><span class="cov8" title="1">{
                b = b.AddPayment(&amp;Payment{lovelace, contractAddress, units, pd, nil, isInline})
        }</span> else<span class="cov8" title="1"> if pd != nil </span><span class="cov8" title="1">{
                dataHash, _ := PlutusData.PlutusDataHash(pd)
                b = b.AddPayment(&amp;Payment{lovelace, contractAddress, units, pd, dataHash.Payload, isInline})
        }</span> else<span class="cov8" title="1"> {
                b = b.AddPayment(&amp;Payment{lovelace, contractAddress, units, nil, nil, isInline})
        }</span>
        <span class="cov8" title="1">if pd != nil &amp;&amp; !isInline </span><span class="cov8" title="1">{
                b = b.AddDatum(pd)
        }</span>
        <span class="cov8" title="1">return b</span>
}

/*
*

                AddRequiredSignerFromBech32 decodes an address in Bech32 format and adds
                its payment and staking parts as required signers.

                Params:
                           address (string): The Bech32-encoded address to decode and add its parts as required signers.
                           addPaymentPart (bool): Indicates whether to add the payment part as a required signer.
                           addStakingPart (bool): Indicates whether to add the staking part as a required signer.

                Returns:
                           *Apollo: A pointer to the modified Apollo instance with the required signers added.
*/
func (b *Apollo) AddRequiredSignerFromBech32(address string, addPaymentPart, addStakingPart bool) *Apollo <span class="cov8" title="1">{
        decoded_addr, _ := Address.DecodeAddress(address)
        if addPaymentPart </span><span class="cov8" title="1">{
                b.requiredSigners = append(b.requiredSigners, serialization.PubKeyHash(decoded_addr.PaymentPart[0:28]))

        }</span>
        <span class="cov8" title="1">if addStakingPart </span><span class="cov8" title="1">{
                b.requiredSigners = append(b.requiredSigners, serialization.PubKeyHash(decoded_addr.StakingPart[0:28]))
        }</span>
        <span class="cov8" title="1">return b</span>

}

/*
*

                AddRequiredSigner appends a public key hash to the list of required signers.

                 Params:
                           pkh (serialization.PubKeyHash): The public key hash to add as a required signer.

                 Returns:
                           *Apollo: A pointer to the modified Apollo instance with the required signer added.
*/
func (b *Apollo) AddRequiredSigner(pkh serialization.PubKeyHash) *Apollo <span class="cov8" title="1">{
        b.requiredSigners = append(b.requiredSigners, pkh)
        return b
}</span>

/*
*

                AddRequiredSignerFromAddress extracts the payment and staking parts from an address and adds them as required signers.

                 Params:
                           address (Address.Address): The address from which to extract the parts and add them as required signers.
                           addPaymentPart (bool): Indicates whether to add the payment part as a required signer.
                           addStakingPart (bool): Indicates whether to add the staking part as a required signer.

                 Returns:
                           *Apollo: A pointer to the modified Apollo instance with the required signers added.
*/
func (b *Apollo) AddRequiredSignerFromAddress(address Address.Address, addPaymentPart, addStakingPart bool) *Apollo <span class="cov8" title="1">{
        if addPaymentPart </span><span class="cov8" title="1">{
                pkh := serialization.PubKeyHash(address.PaymentPart)

                b.requiredSigners = append(b.requiredSigners, pkh)

        }</span>
        <span class="cov8" title="1">if addStakingPart </span><span class="cov8" title="1">{
                pkh := serialization.PubKeyHash(address.StakingPart)

                b.requiredSigners = append(b.requiredSigners, pkh)

        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *Apollo) SetFeePadding(padding int64) *Apollo <span class="cov8" title="1">{
        b.FeePadding = padding
        return b
}</span>

/**
buildOutputs constructs and returns the transaction outputs based on the payments.

Returns:
        []TransactionOutput.TransactionOutput: A slice of transaction outputs.
*/

func (b *Apollo) buildOutputs() []TransactionOutput.TransactionOutput <span class="cov8" title="1">{
        outputs := make([]TransactionOutput.TransactionOutput, 0)
        for _, payment := range b.payments </span><span class="cov8" title="1">{
                outputs = append(outputs, *payment.ToTxOut())
        }</span>
        <span class="cov8" title="1">return outputs</span>

}

/*
*

        buildWitnessSet constructs and returns the witness set for the transaction.

        Returns:
                TransactionWitnessSet.TransactionWitnessSet: The transaction's witness set.
*/
func (b *Apollo) buildWitnessSet() TransactionWitnessSet.TransactionWitnessSet <span class="cov8" title="1">{
        plutusdata := make([]PlutusData.PlutusData, 0)
        plutusdata = append(plutusdata, b.datums...)
        return TransactionWitnessSet.TransactionWitnessSet{
                NativeScripts:  b.nativescripts,
                PlutusV1Script: b.v1scripts,
                PlutusV2Script: b.v2scripts,
                PlutusData:     PlutusData.PlutusIndefArray(plutusdata),
                Redeemer:       b.redeemers,
        }
}</span>

/*
*

        buildFakeWitnessSet constructs and returns a fake witness set used for testing.

        Returns:
                TransactionWitnessSet.TransactionWitnessSet: A fake witness set for testing.
*/
func (b *Apollo) buildFakeWitnessSet() TransactionWitnessSet.TransactionWitnessSet <span class="cov8" title="1">{
        plutusdata := make([]PlutusData.PlutusData, 0)
        plutusdata = append(plutusdata, b.datums...)
        fakeVkWitnesses := make([]VerificationKeyWitness.VerificationKeyWitness, 0)
        fakeVkWitnesses = append(fakeVkWitnesses, VerificationKeyWitness.VerificationKeyWitness{
                Vkey:      constants.FAKE_VKEY,
                Signature: constants.FAKE_SIGNATURE})
        for range b.requiredSigners </span><span class="cov8" title="1">{
                fakeVkWitnesses = append(fakeVkWitnesses, VerificationKeyWitness.VerificationKeyWitness{
                        Vkey:      constants.FAKE_VKEY,
                        Signature: constants.FAKE_SIGNATURE})
        }</span>
        <span class="cov8" title="1">return TransactionWitnessSet.TransactionWitnessSet{
                NativeScripts:  b.nativescripts,
                PlutusV1Script: b.v1scripts,
                PlutusV2Script: b.v2scripts,
                PlutusData:     PlutusData.PlutusIndefArray(plutusdata),
                Redeemer:       b.redeemers,
                VkeyWitnesses:  fakeVkWitnesses,
        }</span>
}

/**
scriptDataHash computes the hash of script data based on redeemers and datums.

Returns:
        *serialization.ScriptDataHash: The computed script data hash.
        error: An error if the scriptDataHash fails.
*/

func (b *Apollo) scriptDataHash() (*serialization.ScriptDataHash, error) <span class="cov8" title="1">{
        if len(b.datums) == 0 &amp;&amp; len(b.redeemers) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">witnessSet := b.buildWitnessSet()
        cost_models := map[int]cbor.Marshaler{}
        redeemers := witnessSet.Redeemer
        PV1Scripts := witnessSet.PlutusV1Script
        PV2Scripts := witnessSet.PlutusV2Script
        datums := witnessSet.PlutusData

        isV1 := len(PV1Scripts) &gt; 0
        if len(redeemers) &gt; 0 </span><span class="cov8" title="1">{
                if len(PV2Scripts) &gt; 0 </span><span class="cov0" title="0">{
                        cost_models = PlutusData.COST_MODELSV2
                }</span> else<span class="cov8" title="1"> if !isV1 </span><span class="cov8" title="1">{
                        cost_models = PlutusData.COST_MODELSV2
                }</span>
        }
        <span class="cov8" title="1">if redeemers == nil </span><span class="cov0" title="0">{
                redeemers = []Redeemer.Redeemer{}
        }</span>
        <span class="cov8" title="1">redeemer_bytes, err := cbor.Marshal(redeemers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var datum_bytes []byte
        if datums.Len() &gt; 0 </span><span class="cov8" title="1">{
                datum_bytes, err = cbor.Marshal(datums)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                datum_bytes = []byte{}
        }</span>
        <span class="cov8" title="1">var cost_model_bytes []byte
        if isV1 </span><span class="cov8" title="1">{
                cost_model_bytes, err = cbor.Marshal(PlutusData.COST_MODELSV1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        } else<span class="cov8" title="1"> {
                cost_model_bytes, err = cbor.Marshal(cost_models)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">total_bytes := append(redeemer_bytes, datum_bytes...)
        total_bytes = append(total_bytes, cost_model_bytes...)
        hashBytes, err := serialization.Blake2bHash(total_bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;serialization.ScriptDataHash{Payload: hashBytes}, nil</span>

}

/*
*

        getMints returns the multi-assets generated from minting.

        Returns:
                MultiAsset.MultiAsset[int64]: The generated multi-assets.
*/
func (b *Apollo) getMints() MultiAsset.MultiAsset[int64] <span class="cov8" title="1">{
        ma := make(MultiAsset.MultiAsset[int64])
        for _, mintUnit := range b.mint </span><span class="cov8" title="1">{
                ma = ma.Add(mintUnit.ToValue().GetAssets())
        }</span>
        <span class="cov8" title="1">return ma</span>
}

/*
*

        MintAssets adds a minting unit to the transaction's minting set.

        Params:
                mintUnit Unit: The minting unit to add.

        Returns:
                *Apollo: A pointer to the Apollo object to support method chaining.
*/
func (b *Apollo) MintAssets(mintUnit Unit) *Apollo <span class="cov8" title="1">{
        b.mint = append(b.mint, mintUnit)
        return b
}</span>

/*
*

        MintAssetsWithRedeemer adds a minting unit with an associated redeemer to the transaction's minting set.

        Params:
                mintUnit Unit: The minting unit to add.
                redeemer Redeemer.Redeemer: The redeemer associated with the minting unit.

        Returns:
                *Apollo: A pointer to the Apollo object with the minting unit added.
*/
func (b *Apollo) MintAssetsWithRedeemer(mintUnit Unit, redeemer Redeemer.Redeemer) *Apollo <span class="cov8" title="1">{
        b.mint = append(b.mint, mintUnit)
        b.mintRedeemers[mintUnit.PolicyId] = redeemer
        b.isEstimateRequired = true
        return b
}</span>

/**
buildTxBody constructs and returns the transaction body for the transaction.

Returns:
        TransactionBody.TransactionBody: The transaction body.
        error: An error if the build fails.
*/

func (b *Apollo) buildTxBody() (TransactionBody.TransactionBody, error) <span class="cov8" title="1">{
        inputs := make([]TransactionInput.TransactionInput, 0)
        for _, utxo := range b.preselectedUtxos </span><span class="cov8" title="1">{
                inputs = append(inputs, utxo.Input)
        }</span>
        <span class="cov8" title="1">collaterals := make([]TransactionInput.TransactionInput, 0)
        for _, utxo := range b.collaterals </span><span class="cov8" title="1">{
                collaterals = append(collaterals, utxo.Input)
        }</span>
        <span class="cov8" title="1">dataHash, err := b.scriptDataHash()
        if err != nil </span><span class="cov0" title="0">{
                return TransactionBody.TransactionBody{}, err
        }</span>
        <span class="cov8" title="1">scriptDataHash := make([]byte, 0)
        if dataHash != nil </span><span class="cov8" title="1">{
                scriptDataHash = dataHash.Payload
        }</span>
        <span class="cov8" title="1">aux_data_hash := b.auxiliaryData.Hash()
        mints := b.getMints()
        txb := TransactionBody.TransactionBody{
                Inputs:            inputs,
                Outputs:           b.buildOutputs(),
                Fee:               b.Fee,
                Ttl:               b.Ttl,
                Mint:              mints,
                AuxiliaryDataHash: aux_data_hash,
                ScriptDataHash:    scriptDataHash,
                RequiredSigners:   b.requiredSigners,
                ValidityStart:     b.ValidityStart,
                Collateral:        collaterals,
                Certificates:      b.certificates,
                Withdrawals:       b.withdrawals,
                ReferenceInputs:   b.referenceInputs}
        if b.totalCollateral != 0 </span><span class="cov8" title="1">{
                txb.TotalCollateral = b.totalCollateral
                txb.CollateralReturn = b.collateralReturn
        }</span>
        <span class="cov8" title="1">return txb, nil</span>
}

/*
*

        buildFullFakeTx constructs and returns a full fake transaction for testing.

        Returns:
                *Transaction.Transaction: A pointer to the fake transaction.
                error: An error if the transaction construction fails.
*/
func (b *Apollo) buildFullFakeTx() (*Transaction.Transaction, error) <span class="cov8" title="1">{
        txBody, err := b.buildTxBody()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if txBody.Fee == 0 </span><span class="cov8" title="1">{
                txBody.Fee = int64(b.Context.MaxTxFee())
        }</span>
        <span class="cov8" title="1">witness := b.buildFakeWitnessSet()
        tx := Transaction.Transaction{
                TransactionBody:       txBody,
                TransactionWitnessSet: witness,
                Valid:                 true,
                AuxiliaryData:         b.auxiliaryData}
        bytes, _ := tx.Bytes()
        if len(bytes) &gt; b.Context.GetProtocolParams().MaxTxSize </span><span class="cov0" title="0">{
                return nil, errors.New("transaction too large")
        }</span>
        <span class="cov8" title="1">return &amp;tx, nil</span>
}

/*
*

        estimateFee estimates the transaction fee based on execution units and transaction size.

        Returns:
                int64: The estimated transaction fee.
*/
func (b *Apollo) estimateFee() int64 <span class="cov8" title="1">{
        pExU := Redeemer.ExecutionUnits{Mem: 0, Steps: 0}
        for _, redeemer := range b.redeemers </span><span class="cov8" title="1">{
                pExU.Sum(redeemer.ExUnits)
        }</span>
        <span class="cov8" title="1">fftx, err := b.buildFullFakeTx()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">fakeTxBytes, _ := fftx.Bytes()
        estimatedFee := Utils.Fee(b.Context, len(fakeTxBytes), pExU.Steps, pExU.Mem)
        estimatedFee += b.FeePadding
        return estimatedFee</span>

}

/*
*

        getAvailableUtxos returns the available unspent transaction outputs (UTXOs) for the transaction.

        Returns:
                []UTxO.UTxO: A slice of available UTXOs.
*/
func (b *Apollo) getAvailableUtxos() []UTxO.UTxO <span class="cov8" title="1">{
        availableUtxos := make([]UTxO.UTxO, 0)
        for _, utxo := range b.utxos </span><span class="cov8" title="1">{
                if !slices.Contains(b.usedUtxos, utxo.GetKey()) </span><span class="cov8" title="1">{
                        availableUtxos = append(availableUtxos, utxo)
                }</span>
        }
        <span class="cov8" title="1">return availableUtxos</span>
}

/*
*

        setRedeemerIndexes function sets indexes for redeemers in
        the transaction based on UTxO inputs.

        Returns:
                *Apollo: A pointer to the Apollo object with indexes and redeemers set.
*/
func (b *Apollo) setRedeemerIndexes() *Apollo <span class="cov8" title="1">{
        sorted_inputs := SortInputs(b.preselectedUtxos)
        done := make([]string, 0)
        for i, utxo := range sorted_inputs </span><span class="cov8" title="1">{
                key := hex.EncodeToString(utxo.Input.TransactionId) + fmt.Sprint(utxo.Input.Index)
                val, ok := b.redeemersToUTxO[key]
                if ok &amp;&amp; val.Tag == Redeemer.SPEND </span><span class="cov8" title="1">{
                        done = append(done, key)
                        redeem := b.redeemersToUTxO[key]
                        redeem.Index = i
                        b.redeemersToUTxO[key] = redeem
                }</span> else<span class="cov8" title="1"> if ok &amp;&amp; val.Tag == Redeemer.MINT </span>{<span class="cov0" title="0">
                        //TODO: IMPLEMENT FOR MINTS
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

/*
*

        AttachDatum attaches a datum to the transaction.

        Params:
                datum *PlutusData.PlutusData: The datum to attach.

        Returns:
                *Apollo: A pointer to the Apollo object with the datum added.
*/
func (b *Apollo) AttachDatum(datum *PlutusData.PlutusData) *Apollo <span class="cov8" title="1">{
        b.datums = append(b.datums, *datum)
        return b
}</span>

/**
setCollateral function sets collateral for the transaction.

Returns:
        *Apollo: A pointer to the Apollo object to support method chaining.
        error: An error if the setCollateral fails.
*/

func (b *Apollo) setCollateral() (*Apollo, error) <span class="cov8" title="1">{
        if len(b.collaterals) &gt; 0 </span><span class="cov8" title="1">{
                collateral_amount := 5_000_000
                for _, utxo := range b.collaterals </span><span class="cov8" title="1">{
                        if int(utxo.Output.GetValue().GetCoin()) &gt;= collateral_amount+1_000_000 &amp;&amp; len(utxo.Output.GetValue().GetAssets()) &lt;= 5 </span><span class="cov8" title="1">{
                                b.totalCollateral = collateral_amount
                                return_amount := utxo.Output.GetValue().GetCoin() - int64(collateral_amount)
                                returnOutput := TransactionOutput.SimpleTransactionOutput(b.inputAddresses[0], Value.SimpleValue(return_amount, utxo.Output.GetValue().GetAssets()))
                                b.collateralReturn = &amp;returnOutput
                        }</span>
                }
                <span class="cov8" title="1">return b, nil</span>
        }
        <span class="cov8" title="1">witnesses := b.buildWitnessSet()
        if len(witnesses.PlutusV1Script) == 0 &amp;&amp;
                len(witnesses.PlutusV2Script) == 0 &amp;&amp;
                len(b.referenceInputs) == 0 </span><span class="cov8" title="1">{
                return b, nil
        }</span>
        <span class="cov8" title="1">availableUtxos := b.getAvailableUtxos()
        collateral_amount := 5_000_000
        for _, utxo := range availableUtxos </span><span class="cov8" title="1">{
                if int(utxo.Output.GetValue().GetCoin()) &gt;= collateral_amount &amp;&amp; len(utxo.Output.GetValue().GetAssets()) &lt;= 5 </span><span class="cov8" title="1">{
                        return_amount := utxo.Output.GetValue().GetCoin() - int64(collateral_amount)
                        min_lovelace := Utils.MinLovelacePostAlonzo(TransactionOutput.SimpleTransactionOutput(b.inputAddresses[0], Value.SimpleValue(return_amount, utxo.Output.GetAmount().GetAssets())), b.Context)
                        if min_lovelace &gt; return_amount &amp;&amp; return_amount != 0 </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov8" title="1"> if return_amount == 0 &amp;&amp; len(utxo.Output.GetAmount().GetAssets()) == 0 </span><span class="cov0" title="0">{
                                b.collaterals = append(b.collaterals, utxo)
                                b.totalCollateral = collateral_amount
                                return b, nil
                        }</span> else<span class="cov8" title="1"> {
                                returnOutput := TransactionOutput.SimpleTransactionOutput(b.inputAddresses[0], Value.SimpleValue(return_amount, utxo.Output.GetValue().GetAssets()))
                                b.collaterals = append(b.collaterals, utxo)
                                b.collateralReturn = &amp;returnOutput
                                b.totalCollateral = collateral_amount
                                return b, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, utxo := range availableUtxos </span><span class="cov0" title="0">{
                if int(utxo.Output.GetValue().GetCoin()) &gt;= collateral_amount </span><span class="cov0" title="0">{
                        return_amount := utxo.Output.GetValue().GetCoin() - int64(collateral_amount)
                        min_lovelace := Utils.MinLovelacePostAlonzo(TransactionOutput.SimpleTransactionOutput(b.inputAddresses[0], Value.SimpleValue(return_amount, utxo.Output.GetAmount().GetAssets())), b.Context)
                        if min_lovelace &gt; return_amount &amp;&amp; return_amount != 0 </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov0" title="0"> if return_amount == 0 &amp;&amp; len(utxo.Output.GetAmount().GetAssets()) == 0 </span><span class="cov0" title="0">{
                                b.collaterals = append(b.collaterals, utxo)
                                b.totalCollateral = collateral_amount
                                return b, nil
                        }</span> else<span class="cov0" title="0"> {
                                returnOutput := TransactionOutput.SimpleTransactionOutput(b.inputAddresses[0], Value.SimpleValue(return_amount, utxo.Output.GetValue().GetAssets()))
                                b.collaterals = append(b.collaterals, utxo)
                                b.collateralReturn = &amp;returnOutput
                                b.totalCollateral = collateral_amount
                                return b, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return b, errors.New("NoCollateral")</span>
}

/*
*

        Clone creates a deep copy of the Apollo object.

        Returns:
                *Apollo: A pointer to the cloned Apollo object.
*/
func (b *Apollo) Clone() *Apollo <span class="cov8" title="1">{
        clone := *b
        return &amp;clone
}</span>

/*
*

        estimateExUnits estimates the execution units for redeemers and updates them.

        Returns:
                map[string]Redeemer.ExecutionUnits: A map of estimated execution units.
*/
func (b *Apollo) estimateExunits() map[string]Redeemer.ExecutionUnits <span class="cov8" title="1">{
        cloned_b := b.Clone()
        cloned_b.isEstimateRequired = false
        updated_b, _ := cloned_b.Complete()
        //updated_b = updated_b.fakeWitness()
        tx_cbor, _ := cbor.Marshal(updated_b.tx)
        return b.Context.EvaluateTx(tx_cbor)
}</span>

/*
*

        updateExUnits updates the execution units in the transaction based on estimates.

        Returns:
                *Apollo: A pointer to the Apollo object to support method chaining.
*/
func (b *Apollo) updateExUnits() *Apollo <span class="cov8" title="1">{
        if b.isEstimateRequired </span><span class="cov8" title="1">{
                estimated_execution_units := b.estimateExunits()
                for k, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        key := fmt.Sprintf("%s:%d", Redeemer.RdeemerTagNames[redeemer.Tag], redeemer.Index)
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov8" title="1">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.redeemersToUTxO[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for k, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%s:%d", Redeemer.RdeemerTagNames[redeemer.Tag], redeemer.Index)
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov0" title="0">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.stakeRedeemers[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for k, redeemer := range b.mintRedeemers </span><span class="cov8" title="1">{
                        key := fmt.Sprintf("%s:%d", Redeemer.RdeemerTagNames[redeemer.Tag], redeemer.Index)
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov0" title="0">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.mintRedeemers[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for _, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.mintRedeemers </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)

                }</span>
        } else<span class="cov8" title="1"> {
                for _, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.mintRedeemers </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>

        }
        <span class="cov8" title="1">return b</span>
}

/*
*

        GetTx returns the transaction associated with the Apollo object.

        Returns:
                *Transacction.Transaction: A pointer to the transaction.
*/
func (b *Apollo) GetTx() *Transaction.Transaction <span class="cov8" title="1">{
        return b.tx
}</span>

/*
*

        Complete assembles and finalizes the Apollo transaction, handling
        inputs, change, fees, collateral and witness data.

        Returns:
                *Apollo: A pointer to the Apollo object representing the completed transaction.
                error: An error if any issues are encountered during the process.
*/
func (b *Apollo) Complete() (*Apollo, error) <span class="cov8" title="1">{
        selectedUtxos := make([]UTxO.UTxO, 0)
        selectedAmount := Value.Value{}
        for _, utxo := range b.preselectedUtxos </span><span class="cov8" title="1">{
                selectedAmount = selectedAmount.Add(utxo.Output.GetValue())
        }</span>
        <span class="cov8" title="1">burnedValue := b.GetBurns()
        mintedValue := b.getPositiveMints()
        selectedAmount = selectedAmount.Add(mintedValue)
        requestedAmount := Value.Value{}
        requestedAmount.Add(burnedValue)
        for _, payment := range b.payments </span><span class="cov8" title="1">{
                payment.EnsureMinUTXO(b.Context)
                requestedAmount = requestedAmount.Add(payment.ToValue())
        }</span>
        <span class="cov8" title="1">requestedAmount.AddLovelace(b.estimateFee() + constants.MIN_LOVELACE)
        unfulfilledAmount := requestedAmount.Sub(selectedAmount)
        unfulfilledAmount = unfulfilledAmount.RemoveZeroAssets()
        available_utxos := SortUtxos(b.getAvailableUtxos())
        //BALANCE TX
        if unfulfilledAmount.GreaterOrEqual(Value.Value{}) </span><span class="cov8" title="1">{
                //BALANCE
                if len(unfulfilledAmount.GetAssets()) &gt; 0 </span><span class="cov8" title="1">{
                        //BALANCE WITH ASSETS
                        for pol, assets := range unfulfilledAmount.GetAssets() </span><span class="cov8" title="1">{
                                for asset, amt := range assets </span><span class="cov8" title="1">{
                                        found := false
                                        selectedSoFar := int64(0)
                                        usedIdxs := make([]int, 0)
                                        for idx, utxo := range available_utxos </span><span class="cov8" title="1">{
                                                ma := utxo.Output.GetValue().GetAssets()
                                                if ma.GetByPolicyAndId(pol, asset) &gt;= amt </span><span class="cov8" title="1">{
                                                        selectedUtxos = append(selectedUtxos, utxo)
                                                        selectedAmount = selectedAmount.Add(utxo.Output.GetValue())
                                                        usedIdxs = append(usedIdxs, idx)
                                                        b.usedUtxos = append(b.usedUtxos, utxo.GetKey())
                                                        found = true
                                                        break</span>
                                                } else<span class="cov8" title="1"> if ma.GetByPolicyAndId(pol, asset) &gt; 0 </span><span class="cov0" title="0">{
                                                        selectedUtxos = append(selectedUtxos, utxo)
                                                        selectedAmount = selectedAmount.Add(utxo.Output.GetValue())
                                                        usedIdxs = append(usedIdxs, idx)
                                                        b.usedUtxos = append(b.usedUtxos, utxo.GetKey())
                                                        selectedSoFar += ma.GetByPolicyAndId(pol, asset)
                                                        if selectedSoFar &gt;= amt </span><span class="cov0" title="0">{
                                                                found = true
                                                                break</span>
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">newAvailUtxos := make([]UTxO.UTxO, 0)
                                        for idx, availutxo := range available_utxos </span><span class="cov8" title="1">{
                                                if !slices.Contains(usedIdxs, idx) </span><span class="cov8" title="1">{
                                                        newAvailUtxos = append(newAvailUtxos, availutxo)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">available_utxos = newAvailUtxos
                                        if !found </span><span class="cov0" title="0">{
                                                return nil, errors.New("missing required assets")
                                        }</span>

                                }
                        }
                }
                <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                        if selectedAmount.Greater(requestedAmount.Add(Value.Value{Am: Amount.Amount{}, Coin: 1_000_000, HasAssets: false})) </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">if len(available_utxos) == 0 </span><span class="cov0" title="0">{
                                return nil, errors.New("not enough funds")
                        }</span>
                        <span class="cov8" title="1">utxo := available_utxos[0]
                        selectedUtxos = append(selectedUtxos, utxo)
                        selectedAmount = selectedAmount.Add(utxo.Output.GetValue())
                        available_utxos = available_utxos[1:]
                        b.usedUtxos = append(b.usedUtxos, utxo.GetKey())</span>
                }

        }
        // ADD NEW SELECTED INPUTS TO PRE SELECTION
        <span class="cov8" title="1">b.preselectedUtxos = append(b.preselectedUtxos, selectedUtxos...)

        //SET REDEEMER INDEXES
        b = b.setRedeemerIndexes()
        //SET COLLATERAL
        b, err := b.setCollateral()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //UPDATE EXUNITS
        <span class="cov8" title="1">b = b.updateExUnits()
        //ADDCHANGEANDFEE
        b, err = b.addChangeAndFee()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //FINALIZE TX
        <span class="cov8" title="1">body, err := b.buildTxBody()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">witnessSet := b.buildWitnessSet()
        b.tx = &amp;Transaction.Transaction{TransactionBody: body, TransactionWitnessSet: witnessSet, AuxiliaryData: b.auxiliaryData, Valid: true}
        return b, nil</span>
}

/*
*

        Check if adding change to a transaction ouput would exceed
        the UTxO limit for the given address.

        Params:
                change: The change amount to add.
                address: The address for which change is being calculated.
                b: The ChainContext providing protocol parameters.

        Returns:
                bool: True if adding change would exceed the UTXO limit, false otherwise.
*/
func isOverUtxoLimit(change Value.Value, address Address.Address, b Base.ChainContext) bool <span class="cov8" title="1">{
        txOutput := TransactionOutput.SimpleTransactionOutput(address, Value.SimpleValue(0, change.GetAssets()))
        encoded, _ := cbor.Marshal(txOutput)
        maxValSize, _ := strconv.Atoi(b.GetProtocolParams().MaxValSize)
        return len(encoded) &gt; maxValSize

}</span>

/*
*

        Split payments into multiple payments if adding change
        exceeds the UTxO limit.

        Params:
                c: The change amount.
                a: The address to which change is being sent.
                b: The ChainContext providing protocol parameters.

        Returns:
                []*Payment: An array of payment objects, split if necessary to avoid exceeding the UTxO limit.
*/
func splitPayments(c Value.Value, a Address.Address, b Base.ChainContext) []*Payment <span class="cov8" title="1">{
        lovelace := c.GetCoin()
        assets := c.GetAssets()
        payments := make([]*Payment, 0)
        newPayment := new(Payment)
        newPayment.Receiver = a
        newPayment.Lovelace = 0
        newPayment.Units = make([]Unit, 0)
        for policy, assets := range assets </span><span class="cov8" title="1">{
                for asset, amt := range assets </span><span class="cov8" title="1">{
                        if !isOverUtxoLimit(newPayment.ToValue(), a, b) </span><span class="cov8" title="1">{
                                if amt &gt; 0 </span><span class="cov8" title="1">{
                                        newPayment.Units = append(newPayment.Units, Unit{
                                                PolicyId: policy.String(),
                                                Name:     asset.String(),
                                                Quantity: int(amt),
                                        })
                                }</span>
                        } else<span class="cov8" title="1"> {

                                minLovelace := Utils.MinLovelacePostAlonzo(
                                        *newPayment.ToTxOut(), b)
                                newPayment.Lovelace = int(minLovelace)
                                lovelace -= minLovelace
                                payments = append(payments, newPayment)
                                newPayment = new(Payment)
                                newPayment.Receiver = a
                                newPayment.Lovelace = 0
                                newPayment.Units = make([]Unit, 0)
                                if amt &gt; 0 </span><span class="cov8" title="1">{
                                        newPayment.Units = append(newPayment.Units, Unit{
                                                PolicyId: policy.String(),
                                                Name:     asset.String(),
                                                Quantity: int(amt),
                                        })
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">payments = append(payments, newPayment)

        payments[len(payments)-1].Lovelace += int(lovelace)
        totalCoin := 0
        for _, payment := range payments </span><span class="cov8" title="1">{
                totalCoin += payment.Lovelace
        }</span>
        <span class="cov8" title="1">return payments</span>

}

func (b *Apollo) GetBurns() (burns Value.Value) <span class="cov8" title="1">{
        burns = Value.Value{}
        for _, mintUnit := range b.mint </span><span class="cov8" title="1">{
                if mintUnit.Quantity &lt; 0 </span><span class="cov8" title="1">{
                        usedUnit := Unit{
                                PolicyId: mintUnit.PolicyId,
                                Name:     mintUnit.Name,
                                Quantity: -mintUnit.Quantity,
                        }
                        burns = burns.Add(usedUnit.ToValue())
                }</span>

        }
        <span class="cov8" title="1">return burns</span>

}

func (b *Apollo) getPositiveMints() (mints Value.Value) <span class="cov8" title="1">{
        mints = Value.Value{}
        for _, mintUnit := range b.mint </span><span class="cov8" title="1">{
                if mintUnit.Quantity &gt; 0 </span><span class="cov8" title="1">{
                        usedUnit := Unit{
                                PolicyId: mintUnit.PolicyId,
                                Name:     mintUnit.Name,
                                Quantity: mintUnit.Quantity,
                        }
                        mints = mints.Add(usedUnit.ToValue())
                }</span>

        }
        <span class="cov8" title="1">return mints</span>

}

/*
*
Add change and fees to the transaction.

Returns:

        *Apollo: A pointer to the Apollo object with change and fees added.
        error: An error if addChangeAndFee fails.
*/
func (b *Apollo) addChangeAndFee() (*Apollo, error) <span class="cov8" title="1">{
        burns := b.GetBurns()
        mints := b.getPositiveMints()
        providedAmount := Value.Value{}
        for _, utxo := range b.preselectedUtxos </span><span class="cov8" title="1">{
                providedAmount = providedAmount.Add(utxo.Output.GetValue())
        }</span>
        <span class="cov8" title="1">providedAmount = providedAmount.Add(mints)
        requestedAmount := Value.Value{}
        for _, payment := range b.payments </span><span class="cov8" title="1">{
                requestedAmount = requestedAmount.Add(payment.ToValue())
        }</span>
        <span class="cov8" title="1">requestedAmount = requestedAmount.Add(burns)
        b.Fee = b.estimateFee()
        requestedAmount.AddLovelace(b.Fee)
        change := providedAmount.Sub(requestedAmount)
        if change.GetCoin() &lt; Utils.MinLovelacePostAlonzo(
                TransactionOutput.SimpleTransactionOutput(b.inputAddresses[0], Value.SimpleValue(0, change.GetAssets())),
                b.Context,
        ) </span><span class="cov8" title="1">{
                if len(b.getAvailableUtxos()) == 0 </span><span class="cov0" title="0">{
                        return b, errors.New("No Remaining UTxOs")
                }</span>
                <span class="cov8" title="1">sortedUtxos := SortUtxos(b.getAvailableUtxos())
                b.preselectedUtxos = append(b.preselectedUtxos, sortedUtxos[0])
                b.usedUtxos = append(b.usedUtxos, sortedUtxos[0].GetKey())
                return b.addChangeAndFee()</span>
        }
        <span class="cov8" title="1">if isOverUtxoLimit(change, b.inputAddresses[0], b.Context) </span><span class="cov8" title="1">{
                adjustedPayments := splitPayments(change, b.inputAddresses[0], b.Context)
                pp := b.payments[:]
                for _, payment := range adjustedPayments </span><span class="cov8" title="1">{
                        b.payments = append(b.payments, payment)
                }</span>
                <span class="cov8" title="1">newestFee := b.estimateFee()
                if newestFee &gt; b.Fee </span><span class="cov8" title="1">{
                        difference := newestFee - b.Fee
                        adjustedPayments[len(adjustedPayments)-1].Lovelace -= int(difference)
                        b.Fee = newestFee
                        b.payments = pp
                        for _, payment := range adjustedPayments </span><span class="cov8" title="1">{
                                b.payments = append(b.payments, payment)
                        }</span>
                }

        } else<span class="cov8" title="1"> {
                payment := Payment{
                        Receiver: b.inputAddresses[0],
                        Lovelace: int(change.GetCoin()),
                        Units:    make([]Unit, 0),
                }
                for policy, assets := range change.GetAssets() </span><span class="cov8" title="1">{
                        for asset, amt := range assets </span><span class="cov8" title="1">{
                                if amt &gt; 0 </span><span class="cov8" title="1">{
                                        payment.Units = append(payment.Units, Unit{
                                                PolicyId: policy.String(),
                                                Name:     asset.String(),
                                                Quantity: int(amt),
                                        })
                                }</span>
                        }
                }
                <span class="cov8" title="1">pp := b.payments[:]
                b.payments = append(b.payments, &amp;payment)

                newestFee := b.estimateFee()
                if newestFee &gt; b.Fee </span><span class="cov8" title="1">{
                        difference := newestFee - b.Fee
                        payment.Lovelace -= int(difference)
                        b.payments = append(pp, &amp;payment)
                        b.Fee = newestFee
                }</span>
        }
        <span class="cov8" title="1">return b, nil</span>
}

/*
*

        Collect a UTXO and its associated redeemer for inclusion in the transaction.

        Params:
                inputUtxo: The UTXO to collect.
                redeemer: The redeemer associated with the UTXO.

        Returns:
                *Apollo: A pointer to the Apollo object with the collected UTXO and redeemer.
*/
func (b *Apollo) CollectFrom(
        inputUtxo UTxO.UTxO,
        redeemer Redeemer.Redeemer,
) *Apollo <span class="cov8" title="1">{
        b.isEstimateRequired = true
        b.preselectedUtxos = append(b.preselectedUtxos, inputUtxo)
        b.usedUtxos = append(b.usedUtxos, inputUtxo.GetKey())
        b.redeemersToUTxO[hex.EncodeToString(inputUtxo.Input.TransactionId)+fmt.Sprint(inputUtxo.Input.Index)] = redeemer
        return b
}</span>

/*
*

        Attach a Plutus V1 script to the Apollo transaction.

        Params:
                script: The Plutus V1 script to attach.

        Returns:
                *Apollo: A pointer to the Apollo objecy with the attached script.
*/
func (b *Apollo) AttachV1Script(script PlutusData.PlutusV1Script) *Apollo <span class="cov8" title="1">{
        hash := PlutusData.PlutusScriptHash(script)
        for _, scriptHash := range b.scriptHashes </span><span class="cov8" title="1">{
                if scriptHash == hex.EncodeToString(hash.Bytes()) </span><span class="cov8" title="1">{
                        return b
                }</span>
        }
        <span class="cov8" title="1">b.v1scripts = append(b.v1scripts, script)
        b.scriptHashes = append(b.scriptHashes, hex.EncodeToString(hash.Bytes()))

        return b</span>
}

/*
*

        Attach a Plutus V2 script to the Apollo transaction.

        Params:
                script: The Plutus V2 script to attach.

        Returns:
                *Apollo: A pointer to the Apollo objecy with the attached script.
*/
func (b *Apollo) AttachV2Script(script PlutusData.PlutusV2Script) *Apollo <span class="cov8" title="1">{
        hash := PlutusData.PlutusScriptHash(script)
        for _, scriptHash := range b.scriptHashes </span><span class="cov8" title="1">{
                if scriptHash == hex.EncodeToString(hash.Bytes()) </span><span class="cov8" title="1">{
                        return b
                }</span>
        }
        <span class="cov8" title="1">b.v2scripts = append(b.v2scripts, script)
        b.scriptHashes = append(b.scriptHashes, hex.EncodeToString(hash.Bytes()))
        return b</span>
}

/**
Set the wallet for the Apollo transaction using a mnemonic.

Params:
        menmonic: The menomic phrase used to generate the wallet.

Returns:
        *Apollo: A pointer to the Apollo object with the wallet set.
        error: an error if setWalletFromMnemonic fails.
*/

func (a *Apollo) SetWalletFromMnemonic(mnemonic string) (*Apollo, error) <span class="cov0" title="0">{
        paymentPath := "m/1852'/1815'/0'/0/0"
        stakingPath := "m/1852'/1815'/0'/2/0"
        hdWall, err := HDWallet.NewHDWalletFromMnemonic(mnemonic, "")
        if err != nil </span><span class="cov0" title="0">{
                return a, err
        }</span>
        <span class="cov0" title="0">paymentKeyPath, err := hdWall.DerivePath(paymentPath)
        if err != nil </span><span class="cov0" title="0">{
                return a, err
        }</span>
        <span class="cov0" title="0">verificationKey_bytes := paymentKeyPath.XPrivKey.PublicKey()
        signingKey_bytes := paymentKeyPath.XPrivKey.Bytes()
        stakingKeyPath, err := hdWall.DerivePath(stakingPath)
        if err != nil </span><span class="cov0" title="0">{
                return a, err
        }</span>
        <span class="cov0" title="0">stakeVerificationKey_bytes := stakingKeyPath.XPrivKey.PublicKey()
        stakeSigningKey_bytes := stakingKeyPath.XPrivKey.Bytes()
        //stake := stakingKeyPath.RootXprivKey.Bytes()
        signingKey := Key.SigningKey{Payload: signingKey_bytes}
        verificationKey := Key.VerificationKey{Payload: verificationKey_bytes}
        stakeSigningKey := Key.StakeSigningKey{Payload: stakeSigningKey_bytes}
        stakeVerificationKey := Key.StakeVerificationKey{Payload: stakeVerificationKey_bytes}
        stakeVerKey := Key.VerificationKey{Payload: stakeVerificationKey_bytes}
        skh, _ := stakeVerKey.Hash()
        vkh, _ := verificationKey.Hash()

        addr := Address.Address{StakingPart: skh[:], PaymentPart: vkh[:], Network: 1, AddressType: Address.KEY_KEY, HeaderByte: 0b00000001, Hrp: "addr"}
        wallet := apollotypes.GenericWallet{SigningKey: signingKey, VerificationKey: verificationKey, Address: addr, StakeSigningKey: stakeSigningKey, StakeVerificationKey: stakeVerificationKey}
        a.wallet = &amp;wallet
        return a, nil</span>
}

// For use with key pairs generated by cardano-cli
func (a *Apollo) SetWalletFromKeypair(vkey string, skey string, network constants.Network) *Apollo <span class="cov0" title="0">{
        verificationKey_bytes, err := hex.DecodeString(vkey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("SetWalletFromKeypair: Failed to decode vkey")
        }</span>
        <span class="cov0" title="0">signingKey_bytes, err := hex.DecodeString(skey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("SetWalletFromKeypair: Failed to decode skey")
        }</span>
        // There are two slightly different interpretations of ed25519,
        // depending on which thing you call the "private key".
        // cardano-cli and the golang library crypto/ed25519 take opposite
        // interpretations. NewKeyFromSeed performs the necessary conversion.
        <span class="cov0" title="0">signingKey := Key.SigningKey{Payload: ed25519.NewKeyFromSeed(signingKey_bytes)}
        verificationKey := Key.VerificationKey{Payload: verificationKey_bytes}
        vkh, _ := verificationKey.Hash()

        addr := Address.Address{}
        if network == constants.MAINNET </span><span class="cov0" title="0">{
                addr = Address.Address{StakingPart: nil, PaymentPart: vkh[:], Network: 1, AddressType: Address.KEY_NONE, HeaderByte: 0b01100001, Hrp: "addr"}
        }</span> else<span class="cov0" title="0"> {
                addr = Address.Address{StakingPart: nil, PaymentPart: vkh[:], Network: 0, AddressType: Address.KEY_NONE, HeaderByte: 0b01100000, Hrp: "addr_test"}
        }</span>
        <span class="cov0" title="0">wallet := apollotypes.GenericWallet{
                SigningKey:           signingKey,
                VerificationKey:      verificationKey,
                Address:              addr,
                StakeSigningKey:      Key.StakeSigningKey{},
                StakeVerificationKey: Key.StakeVerificationKey{},
        }
        a.wallet = &amp;wallet
        return a</span>
}

/*
*

        Set the wallet for the Apollo transaction using a Bech32 address.

        Params:
                address: The Bech32 address to use as the wallet.

        Returns:
                *Apollo: A pointer to the Apollo object with the wallet set.
*/
func (a *Apollo) SetWalletFromBech32(address string) *Apollo <span class="cov8" title="1">{
        addr, err := Address.DecodeAddress(address)
        if err != nil </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">a.wallet = &amp;apollotypes.ExternalWallet{Address: addr}
        return a</span>
}

/*
*

        Set the wallet as the change address for the Apollo transaction.

        Returns:
                *Apollo: A pointer to the Apollo object with the wallet set as the change address.
*/
func (b *Apollo) SetWalletAsChangeAddress() *Apollo <span class="cov8" title="1">{
        if b.wallet == nil </span><span class="cov0" title="0">{
                panic("wallet not set")</span>
                <span class="cov0" title="0">return b</span>
        }
        <span class="cov8" title="1">switch b.Context.(type) </span>{
        case *BlockFrostChainContext.BlockFrostChainContext:<span class="cov0" title="0">

                utxos := b.Context.Utxos(*b.wallet.GetAddress())
                b = b.AddLoadedUTxOs(utxos...)</span>
        default:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">b.inputAddresses = append(b.inputAddresses, *b.wallet.GetAddress())
        return b</span>
}

/*
*

        Sign the Apollo transaction using the wallet's keys.

        Returns:
                *Apollo: A pointer to the Apollo object with the transaction signed.
*/
func (b *Apollo) Sign() *Apollo <span class="cov0" title="0">{
        signatures := b.wallet.SignTx(*b.tx)
        b.tx.TransactionWitnessSet = signatures
        return b
}</span>

/*
*

        Sign the Apollo transaction with the given verification key and signing key.

        Parameters:
                vkey: The verification key to sign with.
                skey: The signing key to sign with.

        Returns:
                *Apollo: A pointer to the Apollo object with the transaction signed.
                error: An error if the signing fails.
*/
func (b *Apollo) SignWithSkey(vkey Key.VerificationKey, skey Key.SigningKey) (*Apollo, error) <span class="cov0" title="0">{
        witness_set := b.GetTx().TransactionWitnessSet
        txHash, err := b.GetTx().TransactionBody.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov0" title="0">signature, err := skey.Sign(txHash)
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov0" title="0">witness_set.VkeyWitnesses = append(witness_set.VkeyWitnesses, VerificationKeyWitness.VerificationKeyWitness{Vkey: vkey, Signature: signature})
        b.GetTx().TransactionWitnessSet = witness_set
        return b, nil</span>
}

/*
*

        Submit function submits the constructed transaction to the blockchain
        network using the associated chain context.

        Returns:
                serialization.TransactionId: The ID of the submitted transaction.
                error: An error, if any, encountered during transaction submission.
*/
func (b *Apollo) Submit() (serialization.TransactionId, error) <span class="cov0" title="0">{
        return b.Context.SubmitTx(*b.tx)
}</span>

/*
*

        LoadTxCbor loads a transaction from its CBOR representation and updates
        the apollo instances.

        Params:
                txCbor (string): The CBOR-encoded representation of the transaction.

        Returns:
                *Apollo: A pointer to the modified Apollo instance with the loaded transaction.
                error: An error, if any, encountered during loading.
*/
func (b *Apollo) LoadTxCbor(txCbor string) (*Apollo, error) <span class="cov0" title="0">{
        tx := Transaction.Transaction{}
        err := cbor.Unmarshal([]byte(txCbor), &amp;tx)
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov0" title="0">b.tx = &amp;tx
        return b, nil</span>
}

/*
*

                UtxoFromRef retrieves a UTxO (Unspent Transaction Output) given its transaction hash and index.

                Params:
                           txHash (string): The hexadecimal representation of the transaction hash.
                           txIndex (int): The index of the UTxO within the transaction's outputs.

                 Returns:
                           *UTxO.UTxO: A pointer to the retrieved UTxO, or nil if not found.
*/
func (b *Apollo) UtxoFromRef(txHash string, txIndex int) *UTxO.UTxO <span class="cov0" title="0">{
        utxo := b.Context.GetUtxoFromRef(txHash, txIndex)
        if utxo == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return utxo</span>

}

/*
*

        AddVerificationKeyWitness adds a verification key witness to the transaction.

        Params:
                vkw (VerificationKeyWitness.VerificationKeyWitness): The verification key witness to add.

        Returns:
                *Apollo: A pointer to the modified Apollo instance with the added verification key witness.
*/
func (b *Apollo) AddVerificationKeyWitness(vkw VerificationKeyWitness.VerificationKeyWitness) *Apollo <span class="cov0" title="0">{
        b.tx.TransactionWitnessSet.VkeyWitnesses = append(b.tx.TransactionWitnessSet.VkeyWitnesses, vkw)
        return b
}</span>

/*
*

                SetChangeAddressBech32 sets the change address for the transaction using a Bech32-encoded address.

                Params:
                           address (string): The Bech32-encoded address to set as the change address.

                 Returns:
                           *Apollo: A pointer to the modified Apollo instance with the change address set.
*/
func (b *Apollo) SetChangeAddressBech32(address string) *Apollo <span class="cov8" title="1">{
        addr, err := Address.DecodeAddress(address)
        if err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov8" title="1">b.inputAddresses = append(b.inputAddresses, addr)
        return b</span>
}

/*
*

                SetChangeAddress sets the change address for the transaction using an Address object.

                 Params:
                           address (Address.Address): The Address object to set as the change address.

                Returns:
                           *Apollo: A pointer to the modified Apollo instance with the change address set.
*/
func (b *Apollo) SetChangeAddress(address Address.Address) *Apollo <span class="cov8" title="1">{
        b.inputAddresses = append(b.inputAddresses, address)
        return b
}</span>

/*
*

        SetTtl function sets the time-to-live (TTL) for the transaction.

        Params:
                ttl (int64): The TTL value to set fro the transaction.

        Returns:
                *Apollo: A pointer to the modified Apollo instance with the TTl set.
*/
func (b *Apollo) SetTtl(ttl int64) *Apollo <span class="cov8" title="1">{
        b.Ttl = ttl
        return b
}</span>

/*
*

        SetValidityStart function sets the validity start for the transaction.

        Params:
                invalidBefore (int64): The validity start value to set for the transaction.

        Returns:
                   *Apollo: A pointer to the modified Apollo instance with the validity start set.
*/
func (b *Apollo) SetValidityStart(invalidBefore int64) *Apollo <span class="cov8" title="1">{
        b.ValidityStart = invalidBefore
        return b
}</span>

/*
*

        SetShelleyMetadata function sets the Shelley Mary metadata for the transaction's
        auxiliary data.

        Params:
                metadata (Metadata.ShelleyMaryMetadata): The Shelley Mary metadat to set.

        Returns:
                *Apollo: A pointer to the modified Apollo instance with the Shelley Mary metadata set.
*/
func (b *Apollo) SetShelleyMetadata(metadata Metadata.ShelleyMaryMetadata) *Apollo <span class="cov0" title="0">{
        if b.auxiliaryData == nil </span><span class="cov0" title="0">{
                b.auxiliaryData = &amp;Metadata.AuxiliaryData{}
                b.auxiliaryData.SetShelleyMetadata(metadata)
        }</span> else<span class="cov0" title="0"> {
                b.auxiliaryData.SetShelleyMetadata(metadata)
        }</span>
        <span class="cov0" title="0">return b</span>
}

/*
*

        GetUsedUTxOs returns the list of used UTxOs in the transaction.

        Returns:
           []string: The list of used UTxOs as strings.
*/
func (b *Apollo) GetUsedUTxOs() []string <span class="cov0" title="0">{
        return b.usedUtxos
}</span>

/*
*

                SetEstimationExUnitsRequired enables the estimation of execution units
                for the transaction.

                Returns:
                           *Apollo: A pointer to the modified Apollo instance with execution units estimation enabled.
*/
func (b *Apollo) SetEstimationExUnitsRequired() *Apollo <span class="cov8" title="1">{
        b.isEstimateRequired = true
        return b
}</span>

/*
*

        AddReferenceInput adds a reference input to the transaction.

        Params:
                txHash (string): The hexadecimal representation of the reference transaction hash.
                index (int): The index of the reference input within its transaction.

        Returns:
                *Apollo: A pointer to the modified Apollo instance with the added reference input.
*/
func (b *Apollo) AddReferenceInput(txHash string, index int) *Apollo <span class="cov8" title="1">{
        decodedHash, _ := hex.DecodeString(txHash)
        input := TransactionInput.TransactionInput{
                TransactionId: decodedHash,
                Index:         index,
        }
        b.referenceInputs = append(b.referenceInputs, input)
        return b
}</span>

/*
*

                DisableExecutionUnitsEstimation disables the estimation of execution units for the transaction.

                 Returns:
                           *Apollo: A pointer to the modified Apollo instance with execution units estimation disabled.
*/
func (b *Apollo) DisableExecutionUnitsEstimation() *Apollo <span class="cov0" title="0">{
        b.isEstimateRequired = false
        return b
}</span>

func (b *Apollo) AddWithdrawal(address Address.Address, amount int, redeemerData PlutusData.PlutusData) *Apollo <span class="cov0" title="0">{
        if b.withdrawals == nil </span><span class="cov0" title="0">{
                newWithdrawal := Withdrawal.New()
                b.withdrawals = &amp;newWithdrawal
        }</span>
        <span class="cov0" title="0">var stakeAddr [29]byte
        stakeAddr[0] = address.HeaderByte
        if len(address.StakingPart) != 28 </span><span class="cov0" title="0">{
                fmt.Printf("AddWithdrawal: address has invalid or missing staking part: %v\n", address.StakingPart)
        }</span>
        <span class="cov0" title="0">copy(stakeAddr[1:], address.StakingPart)
        err := b.withdrawals.Add(stakeAddr, amount)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("AddWithdrawal: %v\n", err)
                return b
        }</span>
        <span class="cov0" title="0">newRedeemer := Redeemer.Redeemer{
                Tag:     Redeemer.REWARD,
                Index:   b.withdrawals.Size() - 1, // We just added a withdrawal
                Data:    redeemerData,
                ExUnits: Redeemer.ExecutionUnits{}, // This will be filled in when we eval later
        }
        b.stakeRedeemers[fmt.Sprint(b.withdrawals.Size()-1)] = newRedeemer
        return b</span>
}

func (b *Apollo) AddCollateral(utxo UTxO.UTxO) *Apollo <span class="cov8" title="1">{
        b.collaterals = append(b.collaterals, utxo)
        return b
}</span>

func (b *Apollo) CompleteExact(fee int) (*Apollo, error) <span class="cov8" title="1">{
        //SET REDEEMER INDEXES
        b = b.setRedeemerIndexes()
        //SET COLLATERAL
        b, err := b.setCollateral()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //UPDATE EXUNITS
        <span class="cov8" title="1">b = b.updateExUnitsExact(fee)
        //ADDCHANGEANDFEE
        b.Fee = int64(fee)
        //FINALIZE TX
        body, err := b.buildTxBody()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">witnessSet := b.buildWitnessSet()
        b.tx = &amp;Transaction.Transaction{TransactionBody: body, TransactionWitnessSet: witnessSet, AuxiliaryData: b.auxiliaryData, Valid: true}
        return b, nil</span>
}

func (b *Apollo) estimateExunitsExact(fee int) map[string]Redeemer.ExecutionUnits <span class="cov8" title="1">{
        cloned_b := b.Clone()
        cloned_b.isEstimateRequired = false
        updated_b, _ := cloned_b.CompleteExact(fee)
        //updated_b = updated_b.fakeWitness()
        tx_cbor, _ := cbor.Marshal(updated_b.tx)
        return b.Context.EvaluateTx(tx_cbor)
}</span>

func (b *Apollo) updateExUnitsExact(fee int) *Apollo <span class="cov8" title="1">{
        if b.isEstimateRequired </span><span class="cov8" title="1">{
                estimated_execution_units := b.estimateExunitsExact(fee)
                for k, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        key := fmt.Sprintf("%s:%d", Redeemer.RdeemerTagNames[redeemer.Tag], redeemer.Index)
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov8" title="1">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.redeemersToUTxO[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for k, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%s:%d", Redeemer.RdeemerTagNames[redeemer.Tag], redeemer.Index)
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov0" title="0">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.stakeRedeemers[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for k, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%s:%d", Redeemer.RdeemerTagNames[redeemer.Tag], redeemer.Index)
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov0" title="0">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.mintRedeemers[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for _, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)

                }</span>
        } else<span class="cov8" title="1"> {
                for _, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>

        }
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package apollo

import (
        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Policy"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/Value"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/Salvionied/apollo/txBuilding/Utils"
)

type Unit struct {
        PolicyId string
        Name     string
        Quantity int
}

/**
        ToValue converts a Unit to a Value object.

        Returns:
                Value: The constructed Value object representing the asset.
*/
func (u *Unit) ToValue() Value.Value <span class="cov8" title="1">{
        val := Value.Value{}
        policyId := Policy.PolicyId{Value: u.PolicyId}
        ma := MultiAsset.MultiAsset[int64]{}
        aname := AssetName.NewAssetNameFromString(u.Name)
        ma[policyId] = map[AssetName.AssetName]int64{aname: int64(u.Quantity)}
        val.AddAssets(ma)
        return val
}</span>

/**
        NewUnit creates a new Unit with the provided information.

        Params:
                policyId (string): The policy ID of the asset.
                name (string): The name of the asset.
                quantity (int): The quantity of the asset.

        Returns:
                Unit: The newly created Unit instance.
*/
func NewUnit(policyId string, name string, quantity int) Unit <span class="cov8" title="1">{
        return Unit{
                PolicyId: policyId,
                Name:     name,
                Quantity: quantity,
        }
}</span>

type PaymentI interface {
        EnsureMinUTXO(cc Base.ChainContext)
        ToTxOut() *TransactionOutput.TransactionOutput
        ToValue() Value.Value
}

type Payment struct {
        Lovelace  int
        Receiver  Address.Address
        Units     []Unit
        Datum     *PlutusData.PlutusData
        DatumHash []byte
        IsInline  bool
}

/**
        PaymentFromTxOut creates a Payment object from a TransactionOutput.

        Params:
                txOut (*TransactionOutput.TransactionOutput): The TransactionOutput to create the Payment.

        Returns:
                *Payment: The created Payment object.
*/
func PaymentFromTxOut(txOut *TransactionOutput.TransactionOutput) *Payment <span class="cov0" title="0">{
        payment := &amp;Payment{
                Receiver: txOut.GetAddress(),
                Lovelace: int(txOut.GetAmount().GetCoin()),
                IsInline: false,
        }
        hasDatumHash := false
        hasInlineDatum := false
        if txOut.GetDatumHash() != nil </span><span class="cov0" title="0">{
                payment.DatumHash = txOut.GetDatumHash().Payload
                hasDatumHash = true
        }</span>
        <span class="cov0" title="0">if !txOut.GetDatum().Equal(PlutusData.PlutusData{}) </span><span class="cov0" title="0">{
                payment.Datum = txOut.GetDatum()
                hasInlineDatum = true
        }</span>
        <span class="cov0" title="0">if hasDatumHash &amp;&amp; hasInlineDatum </span><span class="cov0" title="0">{
                payment.IsInline = true
        }</span>

        <span class="cov0" title="0">for policyId, assets := range txOut.GetAmount().GetAssets() </span><span class="cov0" title="0">{
                for assetName, quantity := range assets </span><span class="cov0" title="0">{
                        payment.Units = append(payment.Units, Unit{
                                PolicyId: policyId.Value,
                                Name:     assetName.String(),
                                Quantity: int(quantity),
                        })
                }</span>
        }
        <span class="cov0" title="0">return payment</span>
}

/**
        NewPayment creates a new Payment object.

        Params: 
                receiver (string): The receiver's address.
                lovelace (int): The amount in Lovelace.
                units ([]Unit): The assets units to be included.

        Returns:
                *Payment: The newly created Payment object.
*/
func NewPayment(receiver string, lovelace int, units []Unit) *Payment <span class="cov8" title="1">{
        decoded_address, _ := Address.DecodeAddress(receiver)
        return &amp;Payment{
                Lovelace: lovelace,
                Receiver: decoded_address,
                Units:    units,
        }
}</span>

/**
        NewPaymentFromValue creates a new Payment object from an Address
        and Value object.

        Params:
                receiver (Address.Address): The receiver's address.
                value (Value.Value): The value object containing payment details.

        Returns:
                *Payment: The newly created Payment object.
*/
func NewPaymentFromValue(receiver Address.Address, value Value.Value) *Payment <span class="cov8" title="1">{
        payment := &amp;Payment{
                Receiver: receiver,
                Lovelace: int(value.GetCoin()),
        }
        for policyId, assets := range value.GetAssets() </span><span class="cov0" title="0">{
                for assetName, quantity := range assets </span><span class="cov0" title="0">{
                        payment.Units = append(payment.Units, Unit{
                                PolicyId: policyId.Value,
                                Name:     assetName.String(),
                                Quantity: int(quantity),
                        })
                }</span>
        }
        <span class="cov8" title="1">return payment</span>
}

/**
        ToValue converts a Payment to a Value object.

        Returns:
                Value.Value: The constructed Value object representing the payment.
*/
func (p *Payment) ToValue() Value.Value <span class="cov8" title="1">{
        v := Value.Value{}
        for _, unit := range p.Units </span><span class="cov8" title="1">{
                v.AddAssets(unit.ToValue().GetAssets())
        }</span>
        <span class="cov8" title="1">v.AddLovelace(int64(p.Lovelace))
        return v</span>
}

/**
        EnsureMinUTXO ensures that the payment amount meets the minimun UTXO requirement.

        Params:
                cc (Base.ChainContext): The chain context.
*/
func (p *Payment) EnsureMinUTXO(cc Base.ChainContext) <span class="cov8" title="1">{
        if len(p.Units) == 0 &amp;&amp; p.Lovelace &gt;= 1_000_000 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">txOut := p.ToTxOut()
        coins := Utils.MinLovelacePostAlonzo(*txOut, cc)
        if int64(p.Lovelace) &lt; coins </span><span class="cov8" title="1">{
                p.Lovelace = int(coins)
        }</span>
}

/**
        ToTxOut converts a Payment object to a TransactionOutput object.

        Returns:
                   *TransactionOutput.TransactionOutput: The created TransactionOutput object.
*/
func (p *Payment) ToTxOut() *TransactionOutput.TransactionOutput <span class="cov8" title="1">{
        txOut := TransactionOutput.SimpleTransactionOutput(p.Receiver, p.ToValue())
        if p.IsInline </span><span class="cov8" title="1">{
                txO := TransactionOutput.TransactionOutput{}
                txO.IsPostAlonzo = true
                l := PlutusData.DatumOptionInline(p.Datum)
                txO.PostAlonzo.Datum = &amp;l
                txO.PostAlonzo.Address = p.Receiver
                txO.PostAlonzo.Amount = p.ToValue().ToAlonzoValue()

                if p.Datum != nil </span><span class="cov8" title="1">{
                        txOut.SetDatum(p.Datum)
                }</span>
                <span class="cov8" title="1">return &amp;txO</span>
        } else<span class="cov8" title="1"> {
                if p.DatumHash != nil </span><span class="cov8" title="1">{
                        txOut.PreAlonzo.DatumHash = serialization.DatumHash{Payload: p.DatumHash}
                        txOut.PreAlonzo.HasDatum = true

                }</span>
        }

        <span class="cov8" title="1">return &amp;txOut</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package apollo

import (
        "encoding/hex"
        "sort"

        "github.com/Salvionied/apollo/serialization/UTxO"
)

/*
*
SortUtxos sorts a slice of UTxO objects in descending order
based on their amounts.

Params:

        utxos ([]UTxO.UTxO): A slice of UTxO objects to be sorted.

Returns:

        []UTxO.UTxO: A new slice of UTxO objects sorted by descending amounts.
*/
func SortUtxos(utxos []UTxO.UTxO) []UTxO.UTxO <span class="cov8" title="1">{
        res := make([]UTxO.UTxO, len(utxos))
        copy(res, utxos)
        // Sort UTXOs first by large ADA-only UTXOs, then by assets
        sort.Slice(res, func(i, j int) bool </span><span class="cov8" title="1">{
                if !res[i].Output.GetValue().HasAssets &amp;&amp; !res[j].Output.GetValue().HasAssets </span><span class="cov8" title="1">{
                        return res[i].Output.Lovelace() &gt; res[j].Output.Lovelace()
                }</span> else<span class="cov8" title="1"> if res[i].Output.GetValue().HasAssets &amp;&amp; res[j].Output.GetValue().HasAssets </span><span class="cov8" title="1">{
                        return res[i].Output.GetAmount().Greater(res[j].Output.GetAmount())
                }</span> else<span class="cov8" title="1"> {
                        return res[j].Output.GetAmount().HasAssets
                }</span>
        })
        <span class="cov8" title="1">return res</span>
}

/*
*

        SortInputs sorts a slice of UTxO objects based on their strings.

        Params:
                inputs ([]UTxO.UTxO): A slice of UTxO objects to be sorted.

        Returns:
                []UTxO.UTxO: A new slice of UTxO objects sorted based on input strings.
*/
func SortInputs(inputs []UTxO.UTxO) []UTxO.UTxO <span class="cov8" title="1">{
        sortedInputs := make([]UTxO.UTxO, 0)
        sortedInputs = append(sortedInputs, inputs...)
        sort.Slice(sortedInputs, func(i, j int) bool </span><span class="cov8" title="1">{
                iTxId := hex.EncodeToString(sortedInputs[i].Input.TransactionId)
                jTxId := hex.EncodeToString(sortedInputs[j].Input.TransactionId)
                if iTxId != jTxId </span><span class="cov8" title="1">{
                        return iTxId &lt; jTxId
                }</span> else<span class="cov8" title="1"> {
                        return sortedInputs[i].Input.Index &lt; sortedInputs[j].Input.Index
                }</span>
        })
        <span class="cov8" title="1">return sortedInputs</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package apollo

import (
        "fmt"

        "github.com/Salvionied/apollo/constants"

        "github.com/Salvionied/apollo/txBuilding/Backend/BlockFrostChainContext"
        "github.com/Salvionied/apollo/txBuilding/Backend/FixedChainContext"
)

/**
        NewEmptyBackend creates and returns an empty FixedChainContext instance,
        which is iused for cases where no specific backend context is required.

        Returns:
                FixedChainContext.FixedChainContext: An empty FixedChainContext instance.
*/
func NewEmptyBackend() FixedChainContext.FixedChainContext <span class="cov8" title="1">{
        return FixedChainContext.InitFixedChainContext()
}</span>

/**
        NewBlockfrostBackend creates a BlockFrostChainContext instance based
        on the specified network and project ID.

        Params:
                projectId (string): The project ID to authenticate with BlockFrost.
                network (Network): The network to configure the BlockFrost context for.

        Returns:
                BlockFrostChainContext.BlockFrostChainContext: A BlockFrostChainContext instance configured for the specified network.
*/
func NewBlockfrostBackend(
        projectId string,
        network constants.Network,

) (BlockFrostChainContext.BlockFrostChainContext, error) <span class="cov0" title="0">{
        switch network </span>{
        case constants.MAINNET:<span class="cov0" title="0">
                return BlockFrostChainContext.NewBlockfrostChainContext(
                        constants.BLOCKFROST_BASE_URL_MAINNET,
                        int(constants.MAINNET),
                        projectId,
                ), nil</span>
        case constants.TESTNET:<span class="cov0" title="0">

                return BlockFrostChainContext.NewBlockfrostChainContext(
                        constants.BLOCKFROST_BASE_URL_TESTNET,
                        int(constants.TESTNET),
                        projectId,
                ), nil</span>
        case constants.PREVIEW:<span class="cov0" title="0">

                return BlockFrostChainContext.NewBlockfrostChainContext(
                        constants.BLOCKFROST_BASE_URL_PREVIEW,
                        int(constants.TESTNET),
                        projectId,
                ), nil</span>
        case constants.PREPROD:<span class="cov0" title="0">

                return BlockFrostChainContext.NewBlockfrostChainContext(
                        constants.BLOCKFROST_BASE_URL_PREPROD,
                        int(constants.TESTNET),
                        projectId,
                ), nil</span>
        default:<span class="cov0" title="0">
                return BlockFrostChainContext.BlockFrostChainContext{}, fmt.Errorf("Invalid network")</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package plutusencoder

import (
        "encoding/hex"
        "errors"
        "fmt"
        "reflect"
        "strconv"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/fxamacker/cbor/v2"
)

func GetAddressPlutusData(address Address.Address) (*PlutusData.PlutusData, error) <span class="cov8" title="1">{
        switch address.AddressType </span>{
        case Address.KEY_KEY:<span class="cov8" title="1">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          121,
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value: PlutusData.PlutusIndefArray{
                                                                PlutusData.PlutusData{
                                                                        TagNr:          121,
                                                                        PlutusDataType: PlutusData.PlutusArray,
                                                                        Value: PlutusData.PlutusIndefArray{
                                                                                PlutusData.PlutusData{
                                                                                        TagNr:          0,
                                                                                        Value:          address.StakingPart,
                                                                                        PlutusDataType: PlutusData.PlutusBytes},
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }, nil</span>

        case Address.SCRIPT_KEY:<span class="cov8" title="1">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          121,
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value: PlutusData.PlutusIndefArray{
                                                                PlutusData.PlutusData{
                                                                        TagNr:          121,
                                                                        PlutusDataType: PlutusData.PlutusArray,
                                                                        Value: PlutusData.PlutusIndefArray{
                                                                                PlutusData.PlutusData{
                                                                                        TagNr:          0,
                                                                                        Value:          address.StakingPart,
                                                                                        PlutusDataType: PlutusData.PlutusBytes},
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }, nil</span>
        case Address.KEY_SCRIPT:<span class="cov0" title="0">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          121,
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value: PlutusData.PlutusIndefArray{
                                                                PlutusData.PlutusData{
                                                                        TagNr:          122,
                                                                        PlutusDataType: PlutusData.PlutusArray,
                                                                        Value: PlutusData.PlutusIndefArray{
                                                                                PlutusData.PlutusData{
                                                                                        TagNr:          0,
                                                                                        Value:          address.StakingPart,
                                                                                        PlutusDataType: PlutusData.PlutusBytes},
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }, nil</span>
        case Address.SCRIPT_SCRIPT:<span class="cov0" title="0">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          121,
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value: PlutusData.PlutusIndefArray{
                                                                PlutusData.PlutusData{
                                                                        TagNr:          122,
                                                                        PlutusDataType: PlutusData.PlutusArray,
                                                                        Value: PlutusData.PlutusIndefArray{
                                                                                PlutusData.PlutusData{
                                                                                        TagNr:          0,
                                                                                        Value:          address.StakingPart,
                                                                                        PlutusDataType: PlutusData.PlutusBytes},
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }, nil</span>
        case Address.KEY_NONE:<span class="cov8" title="1">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value:          PlutusData.PlutusIndefArray{},
                                },
                        },
                }, nil</span>
        case Address.SCRIPT_NONE:<span class="cov8" title="1">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value:          PlutusData.PlutusIndefArray{},
                                },
                        },
                }, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("error: Pointer Addresses are not supported")</span>
        }
}

func MarshalPlutus(v interface{}) (*PlutusData.PlutusData, error) <span class="cov8" title="1">{
        var overallContainer interface{}
        var containerConstr = uint64(0)
        var isMap = false
        var isIndef = true
        types := reflect.TypeOf(v)
        values := reflect.ValueOf(v)
        //get Container type
        fields, ok := types.FieldByName("_")
        typeOfStruct := fields.Tag.Get("plutusType")
        if typeOfStruct == "Map" </span><span class="cov8" title="1">{
                isMap = true
        }</span>
        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                typeOfStruct := fields.Tag.Get("plutusType")
                Constr := fields.Tag.Get("plutusConstr")
                if Constr != "" </span><span class="cov8" title="1">{
                        parsedConstr, err := strconv.Atoi(Constr)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("error parsing constructor: %v", err)
                        }</span>
                        <span class="cov8" title="1">if parsedConstr &lt; 7 </span><span class="cov8" title="1">{
                                containerConstr = 121 + uint64(parsedConstr)
                        }</span> else<span class="cov8" title="1"> if 7 &lt;= parsedConstr &amp;&amp; parsedConstr &lt;= 1400 </span><span class="cov8" title="1">{
                                containerConstr = 1280 + uint64(parsedConstr-7)
                        }</span> else<span class="cov8" title="1"> {
                                return nil, fmt.Errorf("parsedConstr value is above 1400")
                        }</span>
                }
                <span class="cov8" title="1">switch typeOfStruct </span>{
                case "IndefList":<span class="cov8" title="1">
                        overallContainer = PlutusData.PlutusIndefArray{}</span>
                case "Map":<span class="cov8" title="1">
                        overallContainer = map[serialization.CustomBytes]PlutusData.PlutusData{}
                        isMap = true</span>
                case "DefList":<span class="cov8" title="1">
                        overallContainer = PlutusData.PlutusDefArray{}
                        isIndef = false</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("error: unknown type")</span>
                }
                //get fields
                <span class="cov8" title="1">for i := 0; i &lt; types.NumField(); i++ </span><span class="cov8" title="1">{
                        f := types.Field(i)
                        if !f.IsExported() </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">tag := f.Tag
                        name := f.Name
                        constr := uint64(0)
                        typeOfField := tag.Get("plutusType")
                        constrOfField := tag.Get("plutusConstr")
                        if constrOfField != "" </span><span class="cov8" title="1">{
                                parsedConstr, err := strconv.Atoi(constrOfField)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("error parsing constructor: %v", err)
                                }</span>
                                <span class="cov8" title="1">if parsedConstr &lt; 7 </span><span class="cov8" title="1">{
                                        constr = 121 + uint64(parsedConstr)
                                }</span> else<span class="cov8" title="1"> if 7 &lt;= parsedConstr &amp;&amp; parsedConstr &lt;= 1400 </span><span class="cov8" title="1">{
                                        constr = 1280 + uint64(parsedConstr-7)
                                }</span> else<span class="cov8" title="1"> {
                                        return nil, fmt.Errorf("parsedConstr value is above 1400")
                                }</span>
                        }
                        <span class="cov8" title="1">switch typeOfField </span>{
                        case "Bytes":<span class="cov8" title="1">
                                if values.Field(i).Kind() != reflect.Slice </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("error: Bytes field is not a slice")
                                }</span>
                                <span class="cov8" title="1">pdb := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusBytes,
                                        Value:          values.Field(i).Interface().([]byte),
                                        TagNr:          constr,
                                }
                                if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdb
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdb)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdb)
                                        }</span>
                                }
                        case "Int":<span class="cov8" title="1">
                                if values.Field(i).Kind() != reflect.Int64 </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("error: Int field is not int64")
                                }</span>
                                <span class="cov8" title="1">pdi := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusInt,
                                        Value:          values.Field(i).Interface().(int64),
                                        TagNr:          constr,
                                }
                                if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)

                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdi
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdi)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdi)
                                        }</span>
                                }
                        case "StringBytes":<span class="cov8" title="1">
                                if values.Field(i).Kind() != reflect.String </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("error: StringBytes field is not string")
                                }</span>
                                <span class="cov8" title="1">pdsb := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusBytes,
                                        Value:          []byte(values.Field(i).Interface().(string)),
                                        TagNr:          constr,
                                }
                                if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdsb
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdsb)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdsb)
                                        }</span>
                                }
                        case "HexString":<span class="cov8" title="1">
                                if values.Field(i).Kind() != reflect.String </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("error: HexString field is not string")
                                }</span>
                                <span class="cov8" title="1">hexString, err := hex.DecodeString(values.Field(i).Interface().(string))
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("error: HexString field is not string")
                                }</span>
                                <span class="cov8" title="1">pdsb := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusBytes,
                                        Value:          hexString,
                                        TagNr:          constr,
                                }
                                if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdsb
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdsb)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdsb)
                                        }</span>
                                }
                        case "Address":<span class="cov8" title="1">
                                addpd, err := GetAddressPlutusData(values.Field(i).Interface().(Address.Address))
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error marshalling: %v", err)
                                }</span>
                                <span class="cov8" title="1">if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = *addpd
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), *addpd)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), *addpd)
                                        }</span>
                                }

                        case "IndefList":<span class="cov8" title="1">
                                container := PlutusData.PlutusIndefArray{}
                                for j := 0; j &lt; values.Field(i).Len(); j++ </span><span class="cov8" title="1">{
                                        pd, err := MarshalPlutus(values.Field(i).Index(j).Interface())
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error marshalling: %v", err)
                                        }</span>
                                        <span class="cov8" title="1">container = append(container, *pd)</span>
                                }
                                <span class="cov8" title="1">if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = PlutusData.PlutusData{
                                                PlutusDataType: PlutusData.PlutusArray,
                                                Value:          container,
                                                TagNr:          constr,
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })

                                        }</span>
                                }
                        case "DefList":<span class="cov8" title="1">
                                container := PlutusData.PlutusDefArray{}
                                for j := 0; j &lt; values.Field(i).Len(); j++ </span><span class="cov8" title="1">{
                                        pd, err := MarshalPlutus(values.Field(i).Index(j).Interface())
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error marshalling: %v", err)
                                        }</span>
                                        <span class="cov8" title="1">container = append(container, *pd)</span>
                                }
                                <span class="cov8" title="1">if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = PlutusData.PlutusData{
                                                PlutusDataType: PlutusData.PlutusArray,
                                                Value:          container,
                                                TagNr:          constr,
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span>
                                }
                        case "Map":<span class="cov0" title="0">
                                container := map[serialization.CustomBytes]PlutusData.PlutusData{}
                                for j := 0; j &lt; values.Field(i).Len(); j++ </span><span class="cov0" title="0">{
                                        pd, err := MarshalPlutus(values.Field(i).Index(j).Interface())
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error marshalling: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">nameBytes := serialization.NewCustomBytes(values.Field(i).Index(j).Field(0).String())
                                        container[nameBytes] = *pd</span>
                                }
                                <span class="cov0" title="0">if isMap </span><span class="cov0" title="0">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = PlutusData.PlutusData{
                                                PlutusDataType: PlutusData.PlutusMap,
                                                Value:          container,
                                                TagNr:          constr,
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        if isIndef </span><span class="cov0" title="0">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusMap,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span> else<span class="cov0" title="0"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusMap,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span>
                                }

                        default:<span class="cov8" title="1">
                                pd, err := MarshalPlutus(values.Field(i).Interface())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error marshalling: %v", err)
                                }</span>
                                <span class="cov8" title="1">if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)

                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = *pd
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), *pd)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), *pd)
                                        }</span>
                                }
                        }
                }

        }
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error: no _ field")
        }</span>
        <span class="cov8" title="1">ptype := PlutusData.PlutusArray
        if isMap </span><span class="cov8" title="1">{
                ptype = PlutusData.PlutusMap
        }</span>
        <span class="cov8" title="1">pd := PlutusData.PlutusData{
                PlutusDataType: ptype,
                Value:          overallContainer,
                TagNr:          containerConstr,
        }
        return &amp;pd, nil</span>
}

func CborUnmarshal(data string, v interface{}, network byte) error <span class="cov8" title="1">{
        decoded, err := hex.DecodeString(data)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error decoding hex: %v", err)
        }</span>
        <span class="cov8" title="1">pd := PlutusData.PlutusData{}
        err = cbor.Unmarshal(decoded, &amp;pd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error unmarshalling: %v", err)
        }</span>
        <span class="cov8" title="1">err = UnmarshalPlutus(&amp;pd, v, network)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error unmarshalling: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func UnmarshalPlutus(data *PlutusData.PlutusData, v interface{}, network byte) (ret error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        ret = errors.New("error unmarshalling")
                }</span>
        }()

        <span class="cov8" title="1">ret = unmarshalPlutus(data, v, data.TagNr, data.PlutusDataType, network)
        return ret</span>
}

func DecodePlutusAddress(data PlutusData.PlutusData, network byte) Address.Address <span class="cov8" title="1">{
        if data.PlutusDataType != PlutusData.PlutusArray &amp;&amp; data.TagNr != 121 &amp;&amp; len(data.Value.(PlutusData.PlutusIndefArray)) != 2 </span><span class="cov0" title="0">{
                return Address.Address{}
        }</span>
        <span class="cov8" title="1">pkh := data.Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].Value.([]byte)
        is_script := data.Value.(PlutusData.PlutusIndefArray)[0].TagNr == 122
        skh := []byte{}
        skh_exists := data.Value.(PlutusData.PlutusIndefArray)[1].TagNr == 121
        is_skh_script := false
        if skh_exists </span><span class="cov8" title="1">{
                is_skh_script = data.Value.(PlutusData.PlutusIndefArray)[1].Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].TagNr == 122
                skh = data.Value.(PlutusData.PlutusIndefArray)[1].Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].Value.([]byte)
        }</span>
        <span class="cov8" title="1">var addrType byte
        if is_script </span><span class="cov8" title="1">{
                if skh_exists </span><span class="cov8" title="1">{
                        if is_skh_script </span><span class="cov0" title="0">{
                                addrType = Address.SCRIPT_SCRIPT
                        }</span> else<span class="cov8" title="1"> {
                                addrType = Address.SCRIPT_KEY
                        }</span>
                } else<span class="cov8" title="1"> {
                        addrType = Address.SCRIPT_NONE
                }</span>
        } else<span class="cov8" title="1"> {
                if skh_exists </span><span class="cov8" title="1">{
                        if is_skh_script </span><span class="cov0" title="0">{
                                addrType = Address.KEY_SCRIPT
                        }</span> else<span class="cov8" title="1"> {
                                addrType = Address.KEY_KEY
                        }</span>
                } else<span class="cov0" title="0"> {
                        addrType = Address.KEY_NONE
                }</span>
        }
        <span class="cov8" title="1">hrp := Address.ComputeHrp(addrType, network)
        header := addrType&lt;&lt;4 | network
        addr := Address.Address{
                PaymentPart: pkh,
                StakingPart: skh,
                AddressType: addrType,
                Network:     network,
                HeaderByte:  header,
                Hrp:         hrp}
        return addr</span>
}

func unmarshalPlutus(data *PlutusData.PlutusData, v interface{}, Plutusconstr uint64, PlutusType PlutusData.PlutusType, network byte) error <span class="cov8" title="1">{
        types := reflect.TypeOf(v)
        if types.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return fmt.Errorf("error: v is not a pointer %v", v)
        }</span>
        <span class="cov8" title="1">constr := data.TagNr
        //get Container type
        tps := types.Elem()
        //values := reflect.ValueOf(tps)
        //isStruct := tps.Kind() == reflect.Struct
        fields, ok := tps.FieldByName("_")
        if ok </span><span class="cov8" title="1">{
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("error: no _ field")
                }</span>
                <span class="cov8" title="1">switch data.PlutusDataType </span>{
                case PlutusData.PlutusArray:<span class="cov8" title="1">
                        if reflect.TypeOf(v).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                                return fmt.Errorf("error: v is not a pointer")
                        }</span>
                        <span class="cov8" title="1">if fields.Tag.Get("plutusType") != "IndefList" &amp;&amp; fields.Tag.Get("plutusType") != "DefList" &amp;&amp; fields.Tag.Get("plutusType") != "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("error: v is not a PlutusList")
                        }</span>
                        <span class="cov8" title="1">plutusConstr := fields.Tag.Get("plutusConstr")
                        if constr != 0 &amp;&amp; constr &gt; 1400 &amp;&amp; (plutusConstr != fmt.Sprint(constr-121) || plutusConstr != fmt.Sprint(constr-1280)) </span><span class="cov0" title="0">{
                                return fmt.Errorf("error: constructorTag does not match, got %s, expected %d", plutusConstr, constr)
                        }</span>

                        <span class="cov8" title="1">arrayType := reflect.TypeOf(data.Value).String()
                        switch arrayType </span>{
                        case "PlutusData.PlutusDefArray":<span class="cov8" title="1">
                                plutusValues, ok := data.Value.(PlutusData.PlutusDefArray)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error: value is not a PlutusDefArray")
                                }</span>
                                <span class="cov8" title="1">for idx, pAEl := range plutusValues </span><span class="cov8" title="1">{
                                        if tps.Field(idx+1).Type.String() == "Address.Address" </span><span class="cov8" title="1">{
                                                addr := DecodePlutusAddress(pAEl, network)
                                                reflect.ValueOf(v).Elem().Field(idx + 1).Set(reflect.ValueOf(addr))
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">switch pAEl.PlutusDataType </span>{
                                        case PlutusData.PlutusBytes:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "[]uint8" </span><span class="cov8" title="1">{
                                                        if tps.Field(idx+1).Type.String() != "string" </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("error: Bytes field is not a slice")
                                                        }</span> else<span class="cov8" title="1"> {
                                                                if reflect.TypeOf(v).Elem().Field(idx+1).Tag.Get("plutusType") == "HexString" </span><span class="cov8" title="1">{
                                                                        reflect.ValueOf(v).Elem().Field(idx + 1).SetString(hex.EncodeToString(pAEl.Value.([]byte)))
                                                                        continue</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).SetString(string(pAEl.Value.([]byte)))
                                                                continue</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).Set(reflect.ValueOf(pAEl.Value))</span>
                                        case PlutusData.PlutusInt:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "int64" </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error: Int field is not int64")
                                                }</span>
                                                <span class="cov8" title="1">x, ok := pAEl.Value.(uint64)
                                                if !ok </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error: Int field is not int64")
                                                }</span>

                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).SetInt(int64(x))</span>
                                        case PlutusData.PlutusArray:<span class="cov8" title="1">
                                                if reflect.TypeOf(v).Elem().Field(idx+1).Type.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                                                        pa, ok := pAEl.Value.(PlutusData.PlutusIndefArray)
                                                        if ok </span><span class="cov8" title="1">{
                                                                val := reflect.ValueOf(v).Elem().Field(idx + 1)
                                                                val.Grow(len(pa))
                                                                val.SetLen(len(pa))
                                                                for secIdx, arrayElement := range pa </span><span class="cov0" title="0">{
                                                                        err := unmarshalPlutus(&amp;arrayElement, val.Index(secIdx).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return fmt.Errorf("error at index %d.%d: %v:", idx, secIdx, err)
                                                                        }</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).Set(val)</span>
                                                        } else<span class="cov8" title="1"> {
                                                                pa2, ok := pAEl.Value.(PlutusData.PlutusDefArray)
                                                                if !ok </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf("error: value is not a PlutusArray")
                                                                }</span>
                                                                <span class="cov8" title="1">val2 := reflect.ValueOf(v).Elem().Field(idx + 1)
                                                                val2.Grow(len(pa2))
                                                                val2.SetLen(len(pa2))
                                                                for secIdx, arrayElement := range pa2 </span><span class="cov8" title="1">{
                                                                        err := unmarshalPlutus(&amp;arrayElement, val2.Index(secIdx).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return fmt.Errorf("error at index %d.%d: %v:", idx, secIdx, err)
                                                                        }</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).Set(val2)</span>
                                                        }
                                                } else<span class="cov8" title="1"> {
                                                        err := unmarshalPlutus(&amp;pAEl, reflect.ValueOf(v).Elem().Field(idx+1).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("error at index %d: %v", idx, err)
                                                        }</span>
                                                }
                                        case PlutusData.PlutusMap:<span class="cov8" title="1">
                                                err := unmarshalPlutus(&amp;pAEl, reflect.ValueOf(v).Elem().Field(idx+1).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error at index %d: %v", idx, err)
                                                }</span>
                                        default:<span class="cov0" title="0">
                                                return fmt.Errorf("error: unknown type")</span>
                                        }
                                }
                        case "PlutusData.PlutusIndefArray":<span class="cov8" title="1">
                                plutusValues, ok := data.Value.(PlutusData.PlutusIndefArray)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error: value is not a PlutusIndefArray")
                                }</span>
                                <span class="cov8" title="1">for idx, pAEl := range plutusValues </span><span class="cov8" title="1">{
                                        if tps.Field(idx+1).Type.String() == "Address.Address" </span><span class="cov8" title="1">{
                                                addr := DecodePlutusAddress(pAEl, network)
                                                reflect.ValueOf(v).Elem().Field(idx + 1).Set(reflect.ValueOf(addr))
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">switch pAEl.PlutusDataType </span>{
                                        case PlutusData.PlutusBytes:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "[]uint8" </span><span class="cov8" title="1">{
                                                        if tps.Field(idx+1).Type.String() != "string" </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("error: Bytes field is not a slice")
                                                        }</span> else<span class="cov8" title="1"> {
                                                                if reflect.TypeOf(v).Elem().Field(idx+1).Tag.Get("plutusType") == "HexString" </span><span class="cov8" title="1">{
                                                                        reflect.ValueOf(v).Elem().Field(idx + 1).SetString(hex.EncodeToString(pAEl.Value.([]byte)))
                                                                        continue</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).SetString(string(pAEl.Value.([]byte)))
                                                                continue</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).Set(reflect.ValueOf(pAEl.Value))</span>
                                        case PlutusData.PlutusInt:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "int64" </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error: Int field is not int64")
                                                }</span>
                                                <span class="cov8" title="1">x, ok := pAEl.Value.(uint64)
                                                if !ok </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error: Int field is not int64")
                                                }</span>

                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).SetInt(int64(x))</span>
                                        case PlutusData.PlutusArray:<span class="cov8" title="1">
                                                if reflect.TypeOf(v).Elem().Field(idx+1).Type.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                                                        pa, ok := pAEl.Value.(PlutusData.PlutusIndefArray)
                                                        if ok </span><span class="cov8" title="1">{
                                                                val := reflect.ValueOf(v).Elem().Field(idx + 1)
                                                                val.Grow(len(pa))
                                                                val.SetLen(len(pa))
                                                                for secIdx, arrayElement := range pa </span><span class="cov8" title="1">{
                                                                        err := unmarshalPlutus(&amp;arrayElement, val.Index(secIdx).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return fmt.Errorf("error at index %d.%d: %v:", idx, secIdx, err)
                                                                        }</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).Set(val)</span>
                                                        } else<span class="cov8" title="1"> {
                                                                pa2, ok := pAEl.Value.(PlutusData.PlutusDefArray)
                                                                if !ok </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf("error: value is not a PlutusArray")
                                                                }</span>
                                                                <span class="cov8" title="1">val2 := reflect.ValueOf(v).Elem().Field(idx + 1)
                                                                val2.Grow(len(pa2))
                                                                val2.SetLen(len(pa2))
                                                                for secIdx, arrayElement := range pa2 </span><span class="cov8" title="1">{
                                                                        err := unmarshalPlutus(&amp;arrayElement, val2.Index(secIdx).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return fmt.Errorf("error at index %d.%d: %v:", idx, secIdx, err)
                                                                        }</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).Set(val2)</span>
                                                        }
                                                } else<span class="cov8" title="1"> {
                                                        err := unmarshalPlutus(&amp;pAEl, reflect.ValueOf(v).Elem().Field(idx+1).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("error at index %d: %v", idx, err)
                                                        }</span>
                                                }
                                        case PlutusData.PlutusMap:<span class="cov8" title="1">
                                                err := unmarshalPlutus(&amp;pAEl, reflect.ValueOf(v).Elem().Field(idx+1).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error at index %d: %v", idx, err)
                                                }</span>
                                        default:<span class="cov0" title="0">
                                                return fmt.Errorf("error: unknown type")</span>
                                        }
                                }
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("error: unknown type")</span>
                        }
                case PlutusData.PlutusMap:<span class="cov8" title="1">
                        values, ok := data.Value.(*map[serialization.CustomBytes]PlutusData.PlutusData)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("error: value is not a PlutusMap")
                        }</span>
                        <span class="cov8" title="1">for idxStringHex, pAEl := range *values </span><span class="cov8" title="1">{
                                idxBytes, _ := hex.DecodeString(idxStringHex.String())
                                idx := string(idxBytes)
                                field, ok := tps.FieldByName(idx)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error: field %s does not exist", idx)
                                }</span>
                                <span class="cov8" title="1">switch field.Type.String() </span>{
                                case "Address.Address":<span class="cov8" title="1">
                                        addr := DecodePlutusAddress(pAEl, network)
                                        reflect.ValueOf(v).Elem().FieldByName(idx).Set(reflect.ValueOf(addr))
                                        continue</span>
                                case "[]uint8":<span class="cov8" title="1">
                                        if pAEl.PlutusDataType != PlutusData.PlutusBytes </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error: Bytes field is not a slice")
                                        }</span>
                                        <span class="cov8" title="1">reflect.ValueOf(v).Elem().FieldByName(idx).Set(reflect.ValueOf(pAEl.Value))</span>
                                case "string":<span class="cov8" title="1">
                                        if pAEl.PlutusDataType != PlutusData.PlutusBytes </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error: Bytes field is not a slice")
                                        }</span>
                                        <span class="cov8" title="1">tp, _ := reflect.TypeOf(v).Elem().FieldByName(idx)
                                        if tp.Tag.Get("plutusType") == "HexString" </span><span class="cov8" title="1">{
                                                reflect.ValueOf(v).Elem().FieldByName(string(idx)).SetString(hex.EncodeToString(pAEl.Value.([]byte)))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">reflect.ValueOf(v).Elem().FieldByName(idx).SetString(string(pAEl.Value.([]byte)))</span>
                                case "int64":<span class="cov8" title="1">
                                        if pAEl.PlutusDataType != PlutusData.PlutusInt </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error: Int field is not int64")
                                        }</span>
                                        <span class="cov8" title="1">x, ok := pAEl.Value.(uint64)
                                        if !ok </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error: Int field is not int64")
                                        }</span>
                                        <span class="cov8" title="1">reflect.ValueOf(v).Elem().FieldByName(idx).SetInt(int64(x))</span>
                                default:<span class="cov8" title="1">
                                        switch pAEl.PlutusDataType </span>{
                                        case PlutusData.PlutusArray:<span class="cov8" title="1">
                                                tp, _ := reflect.TypeOf(v).Elem().FieldByName(idx)

                                                switch tp.Tag.Get("plutusType") </span>{
                                                case "IndefList":<span class="cov8" title="1">
                                                        pa, ok := pAEl.Value.(PlutusData.PlutusIndefArray)
                                                        if !ok </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("error: value is not a PlutusArray")
                                                        }</span>
                                                        <span class="cov8" title="1">val := reflect.ValueOf(v).Elem().FieldByName(idx)
                                                        val.Grow(len(pa))
                                                        val.SetLen(len(pa))
                                                        for secIdx, arrayElement := range pa </span><span class="cov8" title="1">{
                                                                err := unmarshalPlutus(&amp;arrayElement, val.Index(secIdx).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf("error at index %s.%d: %v:", idx, secIdx, err)
                                                                }</span>
                                                        }
                                                        <span class="cov8" title="1">reflect.ValueOf(v).Elem().FieldByName(idx).Set(val)</span>
                                                case "DefList":<span class="cov8" title="1">
                                                        pa, ok := pAEl.Value.(PlutusData.PlutusDefArray)
                                                        if !ok </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("error: value is not a PlutusArray")
                                                        }</span>
                                                        <span class="cov8" title="1">val := reflect.ValueOf(v).Elem().FieldByName(idx)
                                                        val.Grow(len(pa))
                                                        val.SetLen(len(pa))
                                                        for secIdx, arrayElement := range pa </span><span class="cov8" title="1">{
                                                                err := unmarshalPlutus(&amp;arrayElement, val.Index(secIdx).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf("error at index %s.%d: %v:", idx, secIdx, err)
                                                                }</span>
                                                        }
                                                        <span class="cov8" title="1">reflect.ValueOf(v).Elem().FieldByName(idx).Set(val)</span>
                                                }
                                        case PlutusData.PlutusMap:<span class="cov8" title="1">
                                                err := unmarshalPlutus(&amp;pAEl, reflect.ValueOf(v).Elem().FieldByName(idx).Addr().Interface(), pAEl.TagNr, pAEl.PlutusDataType, network)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error at index %s: %v", idx, err)
                                                }</span>
                                        }
                                }
                        }
                default:<span class="cov0" title="0">
                        return fmt.Errorf("error: unknown type")</span>
                }
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("error: no _ field")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package Address

import (
        "encoding/hex"
        "errors"
        "fmt"

        "github.com/Salvionied/apollo/constants"
        "github.com/Salvionied/apollo/crypto/bech32"
        "github.com/Salvionied/apollo/serialization"

        "github.com/fxamacker/cbor/v2"
)

const (
        BYRON          = 0b1000
        KEY_KEY        = 0b0000
        SCRIPT_KEY     = 0b0001
        KEY_SCRIPT     = 0b0010
        SCRIPT_SCRIPT  = 0b0011
        KEY_POINTER    = 0b0100
        SCRIPT_POINTER = 0b0101
        KEY_NONE       = 0b0110
        SCRIPT_NONE    = 0b0111
        NONE_KEY       = 0b1110
        NONE_SCRIPT    = 0b1111
)
const (
        MAINNET = 1
        TESTNET = 0
)

type Address struct {
        PaymentPart []byte
        StakingPart []byte
        Network     byte
        AddressType byte
        HeaderByte  byte
        Hrp         string
}

func WalletAddressFromBytes(payment []byte, staking []byte, network constants.Network) *Address <span class="cov8" title="1">{
        var addr Address
        addr.PaymentPart = payment
        addr.StakingPart = staking
        if network == constants.MAINNET </span><span class="cov8" title="1">{
                addr.Network = MAINNET
        }</span> else<span class="cov8" title="1"> {
                addr.Network = TESTNET
        }</span>
        <span class="cov8" title="1">if len(payment) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if len(staking) == 0 </span><span class="cov8" title="1">{
                addr.AddressType = KEY_NONE
        }</span> else<span class="cov8" title="1"> {
                addr.AddressType = KEY_KEY
        }</span>
        <span class="cov8" title="1">addr.HeaderByte = (addr.AddressType &lt;&lt; 4) | addr.Network
        addr.Hrp = ComputeHrp(addr.AddressType, addr.Network)
        return &amp;addr</span>
}

/**
        This function check if the current address is equal to another address.

        Params:
                addr (*Address): A pointer to the current address.
                other (*Address): A pointer to the other address for comparison.
        
        Returns:
                bool: true if the addresses are equal, false otherwise.
*/

func (addr *Address) Equal(other *Address) bool <span class="cov8" title="1">{
        return addr.String() == other.String()
}</span>

/**
        Debug method returns a formatted string representation of the address for debugging

        Returns:
                string: A formatted debug string representing the address.
*/
func (addr *Address) Debug() string <span class="cov8" title="1">{
        return fmt.Sprintf("{\nPaymentPart: %v\nStakingPart: %v\nNetwork: %v\nAddressType: %v\nHeaderByte: %v\nHrp: %s\n}", addr.PaymentPart, addr.StakingPart, addr.Network, addr.AddressType, addr.HeaderByte, addr.Hrp)
}</span>


/**
        It converts an address to its CBOR (Concise Binary Object Representation) format and returns
        it as a hexadecimal string. This function marshals the address into its binary representation
        using the CBOR encoding. In case of success, it returns the binary data encoded as a 
        hexadecimal string, otherwise a fatal error is logged.

        Returns:
                string: A hexadecimal string representation of the address in CBOR format.
                error: An error if the convertion fails.
*/
func (addr *Address) ToCbor() (string, error) <span class="cov8" title="1">{
        b, err := cbor.Marshal(addr.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error marshalling address to cbor, %s", err)
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(b), nil</span>
}

/**
        MarshalCBOR encodes an address to its CBOR (Concise Binary Object Representation) format.

        Returns:
                   []byte: A slice of bytes representing the address in CBOR format.
                  error: An error, if any, encountered during the encoding process.
*/
func (addr *Address) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal(addr.Bytes())
}</span>

/**
        UnmarshalCBOR decodes a CBOR (Concise Binary Object Representation) encoded address from a byte slice.

        Params:
                value ([]byte): A byte slice containing the CBOR-encoded address.

        Returns:
                error: An error, if any, encountered during the decoding process.
*/
func (addr *Address) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        res := make([]byte, 0)
        err := cbor.Unmarshal(value, &amp;res)
        header := res[0]
        payload := res[1:]
        addr.PaymentPart = payload[:serialization.VERIFICATION_KEY_HASH_SIZE]
        addr.StakingPart = payload[serialization.VERIFICATION_KEY_HASH_SIZE:]
        addr.Network = (header &amp; 0x0F)
        addr.AddressType = (header &amp; 0xF0) &gt;&gt; 4
        addr.HeaderByte = header
        addr.Hrp = ComputeHrp(addr.AddressType, addr.Network)
        return err
}</span>

/**
        This function returns the binary representation of the address. It
        constructs and returns the binary representation of teh address containing
        the header byte, payment part, and staking part (if present).

        Returns:
                []byte: A byte slice representing the binary data of the address.
*/
func (addr Address) Bytes() []byte <span class="cov8" title="1">{
        var payment []byte
        var staking []byte
        payment = addr.PaymentPart
        if len(addr.StakingPart) == 28 </span><span class="cov8" title="1">{
                staking = addr.StakingPart
        }</span> else<span class="cov8" title="1"> {
                staking = make([]byte, 0)
        }</span>
        <span class="cov8" title="1">result := make([]byte, 0)
        result = append(result, addr.HeaderByte)
        result = append(result, payment...)
        return append(result, staking...)</span>

}

/**
        This function returns the string representation of the address.

        Returns:
                string: A string representing the address in Bech32 format.
*/
func (addr Address) String() string <span class="cov8" title="1">{
        byteaddress, err := bech32.ConvertBits(addr.Bytes(), 8, 5, true)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">result, _ := bech32.Encode(addr.Hrp, byteaddress)
        return result</span>
}

/**
        ComputeHrp computes the human-readable part (Hrp) for an address
        based on its address type and network.

        Params:
                 address_type (uint8): The type of the address.
                network (uint8): The network identifier (1 for mainnet, 0 for testnet).

        Returns:
                string: The computed Hrp for address encoding.
*/
func ComputeHrp(address_type uint8, network uint8) string <span class="cov8" title="1">{
        var prefix string
        if address_type == NONE_KEY || address_type == NONE_SCRIPT </span><span class="cov8" title="1">{
                prefix = "stake"
        }</span> else<span class="cov8" title="1"> {
                prefix = "addr"
        }</span>
        <span class="cov8" title="1">var suffix string
        if network == 1 </span><span class="cov8" title="1">{
                suffix = ""
        }</span> else<span class="cov8" title="1"> {
                suffix = "_test"
        }</span>
        <span class="cov8" title="1">return prefix + suffix</span>

}


/** 
        This function decodes a string representation of an address into its corresponding Address structure.

        Parameters:
                value (string): The string representation of the address to decode.

        Returns:
                Address: The decoded Address structure.
                error: An error, if any, encountered during the decoding process.
*/
func DecodeAddress(value string) (Address, error) <span class="cov8" title="1">{
        _, data, err := bech32.Decode(value)
        if err != nil </span><span class="cov8" title="1">{
                return Address{}, err
        }</span>

        <span class="cov8" title="1">decoded_value, _ := bech32.ConvertBits(data, 5, 8, false)

        header := decoded_value[0]
        payload := decoded_value[1:]
        network := (header &amp; 0x0F)
        addr_type := (header &amp; 0xF0) &gt;&gt; 4
        if !(network == 0b0000 || network == 0b0001) </span><span class="cov8" title="1">{
                return Address{}, errors.New("invalid network tag")
        }</span>
        <span class="cov8" title="1">if addr_type == KEY_KEY </span><span class="cov8" title="1">{
                return Address{payload[:serialization.VERIFICATION_KEY_HASH_SIZE], payload[serialization.VERIFICATION_KEY_HASH_SIZE:], network, addr_type, header, ComputeHrp(addr_type, network)}, nil
        }</span> else<span class="cov8" title="1"> if addr_type == SCRIPT_KEY </span><span class="cov8" title="1">{
                return Address{payload[:serialization.VERIFICATION_KEY_HASH_SIZE], payload[serialization.VERIFICATION_KEY_HASH_SIZE:], network, addr_type, header, ComputeHrp(addr_type, network)}, nil
        }</span> else<span class="cov8" title="1"> if addr_type == KEY_SCRIPT </span><span class="cov8" title="1">{
                return Address{payload[:serialization.VERIFICATION_KEY_HASH_SIZE], payload[serialization.VERIFICATION_KEY_HASH_SIZE:], network, addr_type, header, ComputeHrp(addr_type, network)}, nil
        }</span> else<span class="cov8" title="1"> if addr_type == KEY_NONE </span><span class="cov8" title="1">{
                return Address{payload[:serialization.VERIFICATION_KEY_HASH_SIZE], make([]byte, 0), network, addr_type, header, ComputeHrp(addr_type, network)}, nil
        }</span> else<span class="cov8" title="1"> if addr_type == SCRIPT_SCRIPT </span><span class="cov8" title="1">{
                return Address{payload[:serialization.VERIFICATION_KEY_HASH_SIZE], payload[serialization.VERIFICATION_KEY_HASH_SIZE:], network, addr_type, header, ComputeHrp(addr_type, network)}, nil
        }</span> else<span class="cov8" title="1"> if addr_type == SCRIPT_NONE </span><span class="cov8" title="1">{
                return Address{payload[:serialization.VERIFICATION_KEY_HASH_SIZE], make([]byte, 0), network, addr_type, header, ComputeHrp(addr_type, network)}, nil
        }</span> else<span class="cov8" title="1"> if addr_type == NONE_KEY </span><span class="cov8" title="1">{
                return Address{make([]byte, 0), payload[:serialization.VERIFICATION_KEY_HASH_SIZE], network, addr_type, header, ComputeHrp(addr_type, network)}, nil
        }</span> else<span class="cov8" title="1"> {
                return Address{make([]byte, 0), payload[:serialization.VERIFICATION_KEY_HASH_SIZE], network, addr_type, header, ComputeHrp(addr_type, network)}, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package Amount

import "github.com/Salvionied/apollo/serialization/MultiAsset"

type Amount struct {
        _     struct{} `cbor:",toarray"`
        Coin  int64
        Value MultiAsset.MultiAsset[int64]
}

/*
*

        ToAlonzo converts an Amount to its Alonzo representation creating
        a new AlonzoAmount object.

        Params:
                amt (Amount): The original Amount to be converted.

        Returns:
                AlonzoAmount: The Alonzo representation of the Amount.
*/
func (amt Amount) ToAlonzo() AlonzoAmount <span class="cov8" title="1">{
        return AlonzoAmount{
                Coin:  amt.Coin,
                Value: amt.Value.Clone(),
        }
}</span>

/*
*

        ToShelley converts an AlonzoAmount to its Shelley representation
        creating a new Amount object.

        Params:
                amtAl (AlonzoAmount): The original AlonzoAmount to be converted.

        Returns:
                Amount: The Amount representation of the AlonzoAmount.
*/
func (amtAl AlonzoAmount) ToShelley() Amount <span class="cov8" title="1">{
        return Amount{
                Coin:  amtAl.Coin,
                Value: amtAl.Value.Clone(),
        }
}</span>

type AlonzoAmount struct {
        _     struct{} `cbor:",toarray"`
        Coin  int64
        Value MultiAsset.MultiAsset[int64]
}

/*
*

        Clone function creates a deep copy of an AlonzoAmount object.

        Returns:
                AlonzoAmount: A deep copy of the AlonzoAmount.
*/
func (am AlonzoAmount) Clone() AlonzoAmount <span class="cov8" title="1">{
        return AlonzoAmount{
                Coin:  am.Coin,
                Value: am.Value.Clone(),
        }
}</span>

/*
*

        RemoveZeroAssets remove zero-value assets from an amount.

        Returns:
                Amount: A copy of the Amount without zero-value assets.
*/
func (am Amount) RemoveZeroAssets() Amount <span class="cov8" title="1">{
        res := am.Clone()
        res.Value = res.Value.RemoveZeroAssets()
        return res
}</span>

/*
*

        Clone function creates a deep copy of an Amount object.

        Returns:
                AlonzoAmount: A deep copy of the Amount.
*/
func (am Amount) Clone() Amount <span class="cov8" title="1">{
        return Amount{
                Coin:  am.Coin,
                Value: am.Value.Clone(),
        }
}</span>

/*
*

        This function checks if two Amount are equal.

        Params:
                other (Amount): The other Amount to compare.

        Returns:
                bool: true if the two Amount are equal, false otherwise.
*/
func (am Amount) Equal(other Amount) bool <span class="cov8" title="1">{
        return am.Coin == other.Coin &amp;&amp; am.Value.Equal(other.Value)
}</span>

/*
*

        Less function checks if an Amount is less than another Amount.

        Params:
                other (Amount): The other Amount to compare.

        Returns:
                bool: true if the current Amount is less than the other Amount, false otherwise.
*/
func (am Amount) Less(other Amount) bool <span class="cov8" title="1">{
        return am.Coin &lt; other.Coin &amp;&amp; am.Value.Less(other.Value)
}</span>

/*
*

        Greater function checks if an Amount is greater than another Amount.

        Params:
                other (Amount): The other Amount to compare.

        Returns:
                bool: true if the current Amount is greater than the other Amount, false otherwise.
*/
func (am Amount) Greater(other Amount) bool <span class="cov8" title="1">{
        return am.Coin &gt; other.Coin &amp;&amp; am.Value.Greater(other.Value)
}</span>

/*
*

        Add function adds an Amount to the current Amount.

        Params:
                other (Amount): The other Amount to add to the current Amount.

        Returns:
                Amount: The resulting Amount after addition.
*/
func (am Amount) Add(other Amount) Amount <span class="cov8" title="1">{
        am.Coin += other.Coin
        am.Value = am.Value.Add(other.Value)
        return am
}</span>

/*
*

        Sub function subtracts an Amount from the current Amount.

        Params:
                other (Amount): The other Amount to subtract from the current Amount.

        Returns:
                Amount: The resulting Amount after subtraction.
*/
func (am Amount) Sub(other Amount) Amount <span class="cov8" title="1">{
        am.Coin -= other.Coin
        am.Value = am.Value.Sub(other.Value)
        return am
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package Asset

import (
        "reflect"

        "github.com/Salvionied/apollo/serialization/AssetName"
)

type Asset[V int64 | uint64] map[AssetName.AssetName]V

/**
        Clone creates a deep copy of an Asset map.

        Returns:
                Asset[V]: A deep copy of the original Asset map.
*/
func (ma Asset[V]) Clone() Asset[V] <span class="cov8" title="1">{
        result := make(Asset[V])
        for asset, amount := range ma </span><span class="cov8" title="1">{
                result[asset] = amount
        }</span>
        <span class="cov8" title="1">return result</span>
}

/**
        Equal checks if two Asset maps are equal using 
        the function DeepEuqal from the package "reflect".

        Parameters:
                other (Asset[V]): The other Asset map to compare to.

        Returns:
                  bool: true if the two Asset maps are equal, false otherwise.
*/
func (ma Asset[V]) Equal(other Asset[V]) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(ma, other)
}</span>

/**
        Less function checks if the current Asset map is less than 
        another Asset map.

        Parameters:
                other (Asset[V]): The other Asset map to compare to.

        Returns:
                  bool: true if the current Asset map is less than the other, false otherwise.
*/
func (ma Asset[V]) Less(other Asset[V]) bool <span class="cov8" title="1">{
        for asset, amount := range ma </span><span class="cov8" title="1">{
                otherAmount, ok := other[asset]
                if !ok || amount &gt; otherAmount </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

/**
        Greater function checks if the current Asset map is greater than 
        another Asset map.

        Parameters:
                other (Asset[V]): The other Asset map to compare to.

        Returns:
                  bool: true if the current Asset map is greater than the other, false otherwise.
*/
func (ma Asset[V]) Greater(other Asset[V]) bool <span class="cov8" title="1">{
        for asset, amount := range ma </span><span class="cov8" title="1">{
                otherAmount, ok := other[asset]
                if ok &amp;&amp; amount &lt; otherAmount </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

/**
        Sub subtracts another Asset map from the current Asset map.

        Params:
                other (Asset[V]): The Asset map to subtract from the current Asset map.

        Returns:
                Asset[V]: The resulting Asset map after subtraction.
*/
func (ma Asset[V]) Sub(other Asset[V]) Asset[V] <span class="cov8" title="1">{
        for asset, amount := range other </span><span class="cov8" title="1">{
                _, ok := ma[asset]
                if ok </span><span class="cov8" title="1">{
                        ma[asset] -= amount
                }</span> else<span class="cov8" title="1"> {
                        ma[asset] = -amount
                }</span>
        }
        <span class="cov8" title="1">return ma</span>
}

/**
        Add adds another Asset map to the current Asset map.

        Params:
                other (Asset[V]): The Asset map to add to the current Asset map.

        Returns:
                Asset[V]: The resulting Asset map after addition.
*/
func (ma Asset[V]) Add(other Asset[V]) Asset[V] <span class="cov8" title="1">{
        for asset, amount := range other </span><span class="cov8" title="1">{
                _, ok := ma[asset]
                if ok </span><span class="cov8" title="1">{
                        ma[asset] += amount
                }</span> else<span class="cov8" title="1"> {
                        ma[asset] = amount
                }</span>
        }
        <span class="cov8" title="1">return ma</span>
}

/**
        Inverted creates a copy of an Asset map containing opposite amounts
        of the original one.

        Returns:
                Asset[V]: An inverted copy of the original Asset map.
*/
func (ma Asset[V]) Inverted() Asset[V] <span class="cov8" title="1">{
        for asset, amount := range ma </span><span class="cov8" title="1">{
                ma[asset] = -amount
        }</span>
        <span class="cov8" title="1">return ma</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package AssetName

import (
        "encoding/hex"
        "errors"

        "github.com/fxamacker/cbor/v2"
)

type AssetName struct {
        value string
}

/*
internal use only
*/
func NewAssetNameFromHexString(value string) *AssetName <span class="cov8" title="1">{
        _, err := hex.DecodeString(value)

        if err != nil || len(value) &gt; 64 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;AssetName{value: value}</span>
}

func NewAssetNameFromString(value string) AssetName <span class="cov8" title="1">{
        v := hex.EncodeToString([]byte(value))
        return AssetName{value: v}
}</span>

func (an AssetName) String() string <span class="cov8" title="1">{
        decoded, _ := hex.DecodeString(an.value)
        return string(decoded)
}</span>

func (an AssetName) HexString() string <span class="cov8" title="1">{
        return an.value
}</span>

func (an *AssetName) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if an.value == "[]" || an.value == "" </span><span class="cov8" title="1">{
                return cbor.Marshal(make([]byte, 0))
        }</span>

        <span class="cov8" title="1">if len(an.value) &gt; 64 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid asset name length")
        }</span>

        <span class="cov8" title="1">byteSlice, _ := hex.DecodeString(an.value)

        return cbor.Marshal(byteSlice)</span>
}

func (an *AssetName) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var res []byte
        err := cbor.Unmarshal(value, &amp;res)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(res) &gt; 32 </span><span class="cov8" title="1">{
                return errors.New("invalid asset name length")
        }</span>

        <span class="cov8" title="1">an.value = hex.EncodeToString(res)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package HDWallet

import (
        "crypto/sha512"
        "encoding/hex"
        "errors"
        "strconv"
        "strings"

        "github.com/Salvionied/apollo/crypto/bip32"

        "github.com/tyler-smith/go-bip39"
        "golang.org/x/crypto/pbkdf2"
        "golang.org/x/text/unicode/norm"
)

type HDWallet struct {
        RootXprivKey bip32.XPrv
        XPrivKey     bip32.XPrv
        Path         string
        Seed         []byte
        Mnemonic     string
        Passphrase   string
        Entropy      string
}

func tweak_bits(seed []byte) []byte <span class="cov8" title="1">{
        seed[0] &amp;= 0b11111000
        seed[31] &amp;= 0b00011111
        seed[31] |= 0b01000000
        return seed
}</span>

/*
*

        NewHDWalletFromSeed creates a new HDWallet instance from a seed string.

        Params:
                seed (string): The input seed string.

        Returns:
                *HDWallet: A new HDWallet instance.
                error: An error if the new wallet fails.
*/
func NewHDWalletFromSeed(seed string) (*HDWallet, error) <span class="cov8" title="1">{
        seed_converted, err := hex.DecodeString(seed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">seed_modified := tweak_bits(seed_converted)
        privKey, err := bip32.NewXPrv(seed_modified)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;HDWallet{
                RootXprivKey: privKey,
                XPrivKey:     privKey,
                Path:         "m",
                Seed:         seed_converted,
                Mnemonic:     "",
                Passphrase:   "",
                Entropy:      "",
        }, nil</span>

}

/*
*

        GenerateSeed generates a seed string from a mnemonic and passphrase.

        Params:
                mnemonic (string): The mnemonic for seed generation.
                passphrase (string): The passphrase for seed generation.

        Returns:
                string: The seed string in hexadecimal format.
                error: An error if the generation seed fails.
*/
func GenerateSeed(mnemonic string, passphrase string) (string, error) <span class="cov0" title="0">{
        seed, err := bip39.NewSeedWithErrorChecking(mnemonic, passphrase)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(seed), nil</span>
}

func generateSeedFromEntropy(passphrase string, entropy []byte) string <span class="cov8" title="1">{
        res := pbkdf2.Key([]byte(passphrase), entropy, 4096, 96, sha512.New)
        return hex.EncodeToString(res)
}</span>

/**
NewHDWalletFromMnemonic creates a new HDWallet instance from a
mnemonic and passphrase.

Params:
        mnemonic (string): The mnemonic for wallet generation.
        passphrase (string): The passphrase for wallet generation.

Returns:
        *HDWallet: A new HDWallet instance.
        error: An error if the new wallet fails.
*/

func NewHDWalletFromMnemonic(mnemonic string, passphrase string) (*HDWallet, error) <span class="cov8" title="1">{
        mnemo := norm.NFKD.String(mnemonic)
        entropy, error := bip39.EntropyFromMnemonic(mnemonic)
        if error != nil </span><span class="cov0" title="0">{
                return nil, error
        }</span>
        <span class="cov8" title="1">if !bip39.IsMnemonicValid(mnemo) </span><span class="cov0" title="0">{
                return nil, error
        }</span>
        <span class="cov8" title="1">seed := generateSeedFromEntropy(passphrase, entropy)
        wallet, err := NewHDWalletFromSeed(seed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wallet.Seed = []byte(seed)
        wallet.Mnemonic = mnemonic
        wallet.Passphrase = passphrase

        wallet.Entropy = hex.EncodeToString(entropy)
        return wallet, nil</span>
}

func (hd *HDWallet) copy() *HDWallet <span class="cov8" title="1">{
        return &amp;HDWallet{
                RootXprivKey: hd.RootXprivKey,
                XPrivKey:     hd.XPrivKey,
                Path:         hd.Path,
                Seed:         hd.Seed,
                Mnemonic:     hd.Mnemonic,
                Passphrase:   hd.Passphrase,
                Entropy:      hd.Entropy,
        }
}</span>

/*
*

        DerivePath derives a new HDWallet from the current wallet based on
        the path.

        Params:
                path (string): The derivation path in the format "m/".

        Returns:
                *HDWallet: A new HDWallet derived based on the path.
                error: An error if the derived path fails.
*/
func (hd *HDWallet) DerivePath(path string) (*HDWallet, error) <span class="cov8" title="1">{
        if path[:2] != "m/" </span><span class="cov8" title="1">{
                return nil, errors.New("Invalid path")
        }</span>
        <span class="cov8" title="1">derived_wallet := hd.copy()
        for _, index := range strings.Split(strings.TrimLeft(path, "m/"), "/") </span><span class="cov8" title="1">{
                if strings.HasSuffix(index, "'") </span><span class="cov8" title="1">{
                        ind_val, err := strconv.Atoi(string(index[:len(index)-1]))

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">derived_wallet = derived_wallet.Derive(
                                uint32(ind_val), true,
                        )</span>
                } else<span class="cov8" title="1"> {
                        ind_val, err := strconv.Atoi(index)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">derived_wallet = derived_wallet.Derive(
                                uint32(ind_val), false,
                        )</span>
                }
        }
        <span class="cov8" title="1">return derived_wallet, nil</span>
}

/*
*

        Derive function derives a new HDWallet from the current wallet
        based on an index and a flag.

        Params:
                index (uint32): The index for derivation.
                hardened (bool): A flag indicating whether to perform a hardened derivation.

        Returns:
                *HDWallet: A new HDWallet derived based on the index and hardening flag.
*/
func (hd *HDWallet) Derive(index uint32, hardened bool) *HDWallet <span class="cov8" title="1">{
        if hardened </span><span class="cov8" title="1">{
                index += 1 &lt;&lt; 31
        }</span>
        <span class="cov8" title="1">derived_xprivkey := hd.XPrivKey.Derive(index)
        return &amp;HDWallet{
                RootXprivKey: hd.RootXprivKey,
                XPrivKey:     derived_xprivkey,
                Path:         hd.Path + "/" + strconv.Itoa(int(index)),
                Seed:         hd.Seed,
                Mnemonic:     hd.Mnemonic,
                Passphrase:   hd.Passphrase,
                Entropy:      hd.Entropy,
        }</span>

}

/*
*

        GenerateMnemonic function generate a random mnemonic.

        Returns:
                string: A random mnemonic phrase.
                error: An error if the generation of mnemonic fails.
*/
func GenerateMnemonic() (string, error) <span class="cov8" title="1">{
        entropy, err := bip39.NewEntropy(256)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">mnemo, err := bip39.NewMnemonic(entropy)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return mnemo, nil</span>

}

/*
*

        IsMnemonic checks if a given mnemonic pgrase is valid.

        Params:
                mnemonic (string): The mnemonic phrase to validate.

        Returns:
                bool: true if the mnemonic is valid, false otherwise.
*/
func IsMnemonic(mnemonic string) bool <span class="cov8" title="1">{
        return bip39.IsMnemonicValid(mnemonic)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package Key

import (
        "crypto/ed25519"
        "encoding/hex"
        "fmt"

        "github.com/Salvionied/apollo/crypto/bip32"
        "github.com/Salvionied/apollo/serialization"

        "github.com/fxamacker/cbor/v2"
        "golang.org/x/crypto/blake2b"
)

type SigningKey struct {
        Payload []byte
}

/*
*

        Sign function signs a message using the provided key and returns
        the signature.

        Params:
                message ([]byte): The message to sign.
                sk ([]byte): The signing key, which can be either an extended or an ed25519 private key.

        Returns:
                []byte: The signature of the message.
                error: An error if the signing fails.
*/
func Sign(message []byte, sk []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(sk) != ed25519.PrivateKeySize </span><span class="cov0" title="0">{
                sk, err := bip32.NewXPrv(sk)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating signing key from bytes, %s", err)
                }</span>
                <span class="cov0" title="0">signature := sk.Sign(message)
                return signature, nil</span>

        }
        <span class="cov8" title="1">res := ed25519.Sign(sk, message)
        return res, nil</span>
}

/*
*

        Sign function signs a data byte slice using
        the signing key and the returns the signature.

        Params:
                data ([]byte): The data to sign.

        Returns:
                []byte: The signature of the data.
                error: An error if the signing fails.
*/
func (sk SigningKey) Sign(data []byte) ([]byte, error) <span class="cov8" title="1">{
        pk := sk.Payload
        signature, err := Sign(data, pk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return signature, nil</span>
}

type VerificationKey struct {
        Payload []byte
}

/*
*

        UnmarshalCBOR function unmarshals data into a VerificationKey instance.

        Params:
                data ([]byte): The CBOR data to unmarshal.

        Returns:
                error: An error if unmarshaling fails, nil otherwise.
*/
func (vk *VerificationKey) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        final_data := make([]byte, 0)
        err := cbor.Unmarshal(data, &amp;final_data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">vk.Payload = final_data
        return nil</span>
}

/*
*

        MarshalCBOR marshals the VerificationKey instance into CBOR data.

        Returns:
                ([]byte, error): The CBOR-encoded data and error if marshaling fails, nil otherwise.
*/
func (vk *VerificationKey) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal(vk.Payload)
}</span>

/*
*

        VerificationKeyFromCbor creates a VerificationKey
        instance from a CBOR-encoded string.

        Params:
                cbor_string (string): The CBOR-encoded string.

        Returns:
                (*VerificationKey, error): A VerificationKey instance and an error
                                                                   if decoding or unmarshaling fails, nil otherwise.
*/
func VerificationKeyFromCbor(cbor_string string) (*VerificationKey, error) <span class="cov8" title="1">{
        vkey := new(VerificationKey)
        value, err := hex.DecodeString(cbor_string)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = cbor.Unmarshal(value, vkey)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return vkey, nil</span>
}

/*
*

        Hash computes the has of the VerificationKey and returns it as
        public key.

        Returns:
                (serialization.PubKeyHash, error): The computed hash and an error
                                                                                        if computation fails, nil otherwise.
*/
func (vk VerificationKey) Hash() (serialization.PubKeyHash, error) <span class="cov8" title="1">{
        KeyHash, err := Blake224Hash(vk.Payload, 28)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.PubKeyHash{}, err
        }</span>
        <span class="cov8" title="1">r := serialization.PubKeyHash{}
        copy(r[:], KeyHash)
        return r, nil</span>
}

type PaymentKeyPair struct {
        VerificationKey VerificationKey
        SigningKey      SigningKey
}

/*
*

        PaymentKeyPairGenerate generates a PaymentKey pair with a randomly
        generated key pair.

        Returns:
                PaymentKeyPair: A newly generated PaymentKeyPair.
                error: An error if the payment fails.
*/
func PaymentKeyPairGenerate() (*PaymentKeyPair, error) <span class="cov8" title="1">{
        publicKey, privateKey, err := ed25519.GenerateKey(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;PaymentKeyPair{VerificationKey{publicKey}, SigningKey{privateKey}}, nil</span>
}

type PaymentSigningKey SigningKey
type PaymentVerificationKey VerificationKey
type StakeSigningKey SigningKey
type StakeVerificationKey VerificationKey

/*
*

        Blake224Hash computes the Blake2b-224 hash of the provided byte slice.

        Params:
                b ([]byte): The input byte slice to hash.
                len (int): The length of the hash.

        Returns:
                ([]byte, error): The computed hash and an error if computation fails,
                                                 nil otherwise.
*/
func Blake224Hash(b []byte, len int) ([]byte, error) <span class="cov8" title="1">{
        hash, err := blake2b.New(len, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, err = hash.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return hash.Sum(nil), err</span>
}

func SigningKeyFromHexString(hexString string) (*SigningKey, error) <span class="cov8" title="1">{
        skey := new(SigningKey)
        value, err := hex.DecodeString(hexString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">skey.Payload = value
        return skey, nil</span>
}

func VerificationKeyFromHexString(hexString string) (*VerificationKey, error) <span class="cov8" title="1">{
        vkey := new(VerificationKey)
        value, err := hex.DecodeString(hexString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">vkey.Payload = value
        return vkey, nil</span>
}

func (sk SigningKey) ToHexString() string <span class="cov8" title="1">{
        return hex.EncodeToString(sk.Payload)
}</span>

func (vk VerificationKey) ToHexString() string <span class="cov8" title="1">{
        return hex.EncodeToString(vk.Payload)
}</span>

func (sk *SigningKey) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal(sk.Payload)
}</span>

func (sk *SigningKey) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        final_data := make([]byte, 0)
        err := cbor.Unmarshal(data, &amp;final_data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">sk.Payload = final_data
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package Metadata

import (
        "github.com/Salvionied/apollo/serialization/NativeScript"

        "github.com/Salvionied/apollo/serialization"

        "github.com/fxamacker/cbor/v2"
)

type MinimalMetadata map[string]any

type PoliciesMetadata map[string]MinimalMetadata

type TagMetadata map[string]any

type Metadata map[int]TagMetadata

type ShelleyMaryMetadata struct {
        _             struct{}                    `cbor:",toarray,omitempty"`
        Metadata      Metadata                    `cbor:",omitempty"`
        NativeScripts []NativeScript.NativeScript `cbor:",omitempty"`
}

/**
        MarshalCBOR marshals a ShelleyMaryMetadata instance into CBOR-encoded data.

        Returns:
                ([]byte, error): The CBOR-encoded data and an error if marshaling fails,
                                                 nil otherwise.
*/
func (smm *ShelleyMaryMetadata) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        enc, _ := cbor.EncOptions{Sort: cbor.SortLengthFirst}.EncMode()
        if len(smm.NativeScripts) &gt; 0 </span><span class="cov0" title="0">{
                return enc.Marshal(smm)
        }</span> else<span class="cov8" title="1"> {
                return enc.Marshal(smm.Metadata)
        }</span>
}

type AlonzoMetadata struct {
        Metadata      Metadata                    `cbor:"0,keyasint,omitempty"`
        NativeScripts []NativeScript.NativeScript `cbor:"1,keyasint,omitempty"`
        PlutusScripts []uint8                     `cbor:"2,keyasint,omitempty"`
}

type AuxiliaryData struct {
        _basicMeta   Metadata
        _ShelleyMeta ShelleyMaryMetadata
        _AlonzoMeta  AlonzoMetadata
}

/**
        SetBasicMetadata sets the basic metadata for the AuxiliaryData.
*/
func (ad *AuxiliaryData) SetBasicMetadata(value Metadata) <span class="cov8" title="1">{
        ad._basicMeta = value
}</span>

/**
        SetAlonzoMetadata sets the Alonzo metadata for the AuxiliaryData.
*/
func (ad *AuxiliaryData) SetAlonzoMetadata(value AlonzoMetadata) <span class="cov8" title="1">{
        ad._AlonzoMeta = value
}</span>

/**
        SetShelleyMetadata sets the Shelley metadata for the AuxiliaryData.
*/
func (ad *AuxiliaryData) SetShelleyMetadata(value ShelleyMaryMetadata) <span class="cov8" title="1">{
        ad._ShelleyMeta = value
}</span>

/**
        Hash computes computes the has of the AuxiliaryData.

        Returns:
                []byte: The computed hash or nil if all metadata fileds are empty.
*/
func (ad *AuxiliaryData) Hash() []byte <span class="cov8" title="1">{
        if len(ad._basicMeta) != 0 || len(ad._ShelleyMeta.Metadata) != 0 || len(ad._AlonzoMeta.Metadata) != 0 </span><span class="cov8" title="1">{
                marshaled, _ := cbor.Marshal(ad)
                hash, err := serialization.Blake2bHash(marshaled)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return hash</span>
        } else<span class="cov0" title="0"> {
                return nil
        }</span>
}

/**
        UnmarshalCBOR deserializes the AuxiliaryData from a CBOR-encoded byte slice.

        Params:
                value []byte: The CBOR-encoded data to deserialize.

        Returns:
                error: An error if deserialization fails.
*/
func (ad *AuxiliaryData) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        err_shelley := cbor.Unmarshal(value, &amp;ad._ShelleyMeta)
        if err_shelley != nil </span><span class="cov8" title="1">{
                err_basic_meta := cbor.Unmarshal(value, &amp;ad._basicMeta)
                if err_basic_meta != nil </span><span class="cov8" title="1">{
                        return err_basic_meta
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/**
        MarshalCBOR serializes the AUxiliaryData to a CBOR byte slice.

        Returns:
                []byte: The CBOR-serialized AuxiliaryData.
                error: An error if serialization fails.
*/
func (ad *AuxiliaryData) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        enc, _ := cbor.EncOptions{Sort: cbor.SortLengthFirst}.EncMode()
        if len(ad._basicMeta) != 0 </span><span class="cov8" title="1">{
                return enc.Marshal(ad._basicMeta)
        }</span>
        <span class="cov8" title="1">if len(ad._AlonzoMeta.Metadata) != 0 || len(ad._AlonzoMeta.NativeScripts) != 0 || len(ad._AlonzoMeta.PlutusScripts) != 0 </span><span class="cov8" title="1">{
                return enc.Marshal(ad._AlonzoMeta)
        }</span>
        <span class="cov8" title="1">if len(ad._ShelleyMeta.Metadata) == 0 &amp;&amp; len(ad._ShelleyMeta.NativeScripts) == 0 </span><span class="cov8" title="1">{
                return enc.Marshal(nil)
        }</span>
        <span class="cov8" title="1">return enc.Marshal(ad._ShelleyMeta)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package MultiAsset

import (
        "reflect"

        "github.com/Salvionied/apollo/serialization/Asset"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/Policy"
)

type MultiAsset[V int64 | uint64] map[Policy.PolicyId]Asset.Asset[V]

/*
*

        GetByPolicyAndId returns the asset amount given a policy and asset name.

        Params:
                pol Policy.PolicyId: The policy ID.
                asset_name AssetName.AssetName: The asset name.

        Returns:
                V: The asset amount.
*/
func (ma MultiAsset[V]) GetByPolicyAndId(pol Policy.PolicyId, asset_name AssetName.AssetName) V <span class="cov8" title="1">{
        for policy, asset := range ma </span><span class="cov8" title="1">{

                if policy.String() == pol.String() </span><span class="cov8" title="1">{
                        for assetName, amount := range asset </span><span class="cov8" title="1">{
                                if assetName.String() == asset_name.String() </span><span class="cov8" title="1">{
                                        return amount
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return 0</span>
}

/*
*

        RemoveZeroAssets removes assets with a zero amount from the MultiAsset.

        Returns:
                MultiAsset[V]: A MultiAsset with zero-amount assets removed.
*/
func (ma MultiAsset[V]) RemoveZeroAssets() MultiAsset[V] <span class="cov8" title="1">{
        result := make(MultiAsset[V])
        for policy, asset := range ma </span><span class="cov8" title="1">{
                for assetName, amount := range asset </span><span class="cov8" title="1">{
                        if amount != 0 </span><span class="cov8" title="1">{
                                _, ok := result[policy]
                                if ok </span><span class="cov0" title="0">{
                                        result[policy][assetName] = amount
                                }</span> else<span class="cov8" title="1"> {
                                        result[policy] = Asset.Asset[V]{assetName: amount}
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return result</span>
}

/*
*

        Clone creates a deep copy of the MultiAsset.

        Returns:
                MultiAsset[V]: A copy of the MultiAsset.
*/
func (ma MultiAsset[V]) Clone() MultiAsset[V] <span class="cov8" title="1">{
        result := make(MultiAsset[V])
        for policy, asset := range ma </span><span class="cov8" title="1">{
                result[policy] = asset.Clone()
        }</span>
        <span class="cov8" title="1">return result</span>
}

/*
*

        Equal checks if two MultiAsset instances are equal.

        Params:
                other MultiAsset[V]: The other MultiAsset to compare.

        Returns:
                bool: True if the two MultiAsset instances are equal, false otherwise.
*/
func (ma MultiAsset[V]) Equal(other MultiAsset[V]) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(ma, other)
}</span>

/*
*

        Less checks if the current MultiAsset is less
        than another MultiAsset.

        Params:
                other MultiAsset[V]: The other MultiAsset to compare.

        Returns:
                bool: True if the current MultiAsset is less than the other, false otherwise.
*/
func (ma MultiAsset[V]) Less(other MultiAsset[V]) bool <span class="cov8" title="1">{
        for policy, asset := range ma </span><span class="cov8" title="1">{
                otherAsset, ok := other[policy]
                if !ok || !asset.Less(otherAsset) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>

}

/*
*

        Greater checks if the current MultiAsset is greater
        than another MultiAsset.

        Params:
                other MultiAsset[V]: The other MultiAsset to compare.

        Returns:
                bool: True if the current MultiAsset is greater than the other, false otherwise.
*/
func (ma MultiAsset[V]) Greater(other MultiAsset[V]) bool <span class="cov8" title="1">{
        for policy, asset := range ma </span><span class="cov8" title="1">{
                otherAsset, ok := other[policy]
                if ok &amp;&amp; !asset.Greater(otherAsset) &amp;&amp; !asset.Equal(otherAsset) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

/*
*

        Sub subtracts another MultiAsset from the current MultiAsset.

        Params:
                other MultiAsset[V]: The MultiAsset to subtract.

        Returns:
                MultiAsset[V]: The result of the subtraction.
*/
func (ma MultiAsset[V]) Sub(other MultiAsset[V]) MultiAsset[V] <span class="cov8" title="1">{
        result := ma.Clone()
        for policy, asset := range other </span><span class="cov8" title="1">{
                _, ok := result[policy]
                if ok </span><span class="cov8" title="1">{
                        result[policy] = result[policy].Sub(asset)
                }</span> else<span class="cov0" title="0"> {
                        result[policy] = asset.Inverted()
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

/*
*

        Add adds another MultiAsset to the current MultiAsset.

        Params:
                other MultiAsset[V]: The MultiAsset to add.

        Returns:
                MultiAsset[V]: The result of the addition.
*/
func (ma MultiAsset[V]) Add(other MultiAsset[V]) MultiAsset[V] <span class="cov8" title="1">{
        res := ma.Clone()
        for policy, asset := range other </span><span class="cov8" title="1">{
                _, ok := res[policy]
                if ok </span><span class="cov8" title="1">{
                        res[policy] = res[policy].Add(asset)
                }</span> else<span class="cov8" title="1"> {
                        res[policy] = asset
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

/*
*

        Filter returns a MultiAsset containing only the assets that
        satisfy the filter function.

        Params:
                f func(policy Policy.PolicyId, asset Asset.Asset[V]) bool: The filter function.

        Returns:
                MultiAsset[V]: The filtered MultiAsset.
*/
func (ma MultiAsset[V]) Filter(f func(policy Policy.PolicyId, asset AssetName.AssetName, quantity V) bool) MultiAsset[V] <span class="cov8" title="1">{
        result := make(MultiAsset[V])
        for policy, asset := range ma </span><span class="cov8" title="1">{
                for assetName, amount := range asset </span><span class="cov8" title="1">{
                        if f(policy, assetName, amount) </span><span class="cov8" title="1">{
                                _, ok := result[policy]
                                if ok </span><span class="cov0" title="0">{
                                        result[policy][assetName] = amount
                                }</span> else<span class="cov8" title="1"> {
                                        result[policy] = Asset.Asset[V]{assetName: amount}
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return result</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">package NativeScript

import (
        "github.com/Salvionied/apollo/serialization"

        "github.com/fxamacker/cbor/v2"
        "golang.org/x/crypto/blake2b"
)

type ScriptTag int

const (
        ScriptPubKey ScriptTag = iota
        ScriptAll
        ScriptAny
        ScriptNofK
        InvalidBefore
        InvalidHereafter
)

func NewScriptPubKey(keyHash []byte) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: ScriptPubKey, KeyHash: keyHash}
}</span>

func NewScriptAll(nativeScripts []NativeScript) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: ScriptAll, NativeScripts: nativeScripts}
}</span>

func NewScriptAny(nativeScripts []NativeScript) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: ScriptAny, NativeScripts: nativeScripts}
}</span>

func NewScriptNofK(nativeScripts []NativeScript, noK int) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: ScriptNofK, NativeScripts: nativeScripts, NoK: noK}
}</span>

func NewInvalidBefore(before int64) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: InvalidBefore, Before: before}
}</span>

func NewInvalidHereafter(after int64) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: InvalidHereafter, After: after}
}</span>

type NativeScript struct {
        Tag           ScriptTag
        KeyHash       []byte
        NativeScripts []NativeScript
        NoK           int
        Before        int64
        After         int64
}

type SerialScripts struct {
        _             struct{} `cbor:",toarray"`
        Tag           ScriptTag
        NativeScripts []NativeScript
}

type SerialNok struct {
        _             struct{} `cbor:",toarray"`
        Tag           ScriptTag
        NoK           int
        NativeScripts []NativeScript
}

type SerialInt struct {
        _     struct{} `cbor:",toarray"`
        Tag   ScriptTag
        Value int64
}
type SerialHash struct {
        _     struct{} `cbor:",toarray"`
        Tag   ScriptTag
        Value []byte
}

/*
*

        Hash computes the script hash for the NativeScript.

        Returns:
                serialization.ScriptHash: The computed script hash.
                error: An error if the hashing fails.
*/
func (ns NativeScript) Hash() (serialization.ScriptHash, error) <span class="cov8" title="1">{
        finalbytes := []byte{0}
        bytes, err := cbor.Marshal(ns)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov8" title="1">finalbytes = append(finalbytes, bytes...)
        hash, err := blake2b.New(28, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov8" title="1">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov8" title="1">ret := serialization.ScriptHash{}
        copy(ret[:], hash.Sum(nil))
        return ret, nil</span>
}

/*
*

        UnmarshalCBOR decodes the CBOR-encoded data and populates
        the NativeScript fields.

        Params:
                value []byte: The CBOR-encoded data to encode.

        Returns:
                error: An error if decoding fails, nil otherwise.
*/
func (ns *NativeScript) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var tmp = make([]any, 0)
        err := cbor.Unmarshal(value, &amp;tmp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ok, _ := tmp[0].(uint64)
        switch int(ok) </span>{
        case 0:<span class="cov8" title="1">
                tmp := new(SerialHash)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.KeyHash = tmp.Value
                ns.Tag = tmp.Tag
                return err</span>
        case 1:<span class="cov8" title="1">
                tmp := new(SerialScripts)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.Tag = tmp.Tag
                ns.NativeScripts = tmp.NativeScripts
                return err</span>
        case 2:<span class="cov8" title="1">
                tmp := new(SerialScripts)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.Tag = tmp.Tag
                ns.NativeScripts = tmp.NativeScripts
                return err</span>
        case 3:<span class="cov8" title="1">
                tmp := new(SerialNok)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.NativeScripts = tmp.NativeScripts
                ns.Tag = tmp.Tag
                ns.NoK = tmp.NoK
                return err</span>
        case 4:<span class="cov8" title="1">
                tmp := new(SerialInt)
                err := cbor.Unmarshal(value, &amp;tmp)

                ns.Tag = tmp.Tag
                ns.Before = tmp.Value
                return err</span>
        case 5:<span class="cov8" title="1">
                tmp := new(SerialInt)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.Tag = tmp.Tag
                ns.After = tmp.Value
                return err</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

/*
*

        MarshalCBOR encodes the NativeScript into CBOR format.

        Returns:
                []uint8: The CBOR-encoded data.
                error: An error if encoding fails, nil otherwise.
*/
func (ns *NativeScript) MarshalCBOR() ([]uint8, error) <span class="cov8" title="1">{
        switch ns.Tag </span>{
        case 0:<span class="cov8" title="1">
                return cbor.Marshal(SerialHash{Tag: ns.Tag, Value: ns.KeyHash})</span>
        case 1:<span class="cov8" title="1">
                return cbor.Marshal(SerialScripts{Tag: ns.Tag, NativeScripts: ns.NativeScripts})</span>
        case 2:<span class="cov8" title="1">
                return cbor.Marshal(SerialScripts{Tag: ns.Tag, NativeScripts: ns.NativeScripts})</span>
        case 3:<span class="cov8" title="1">
                return cbor.Marshal(SerialNok{Tag: ns.Tag, NoK: ns.NoK, NativeScripts: ns.NativeScripts})</span>
        case 4:<span class="cov8" title="1">
                return cbor.Marshal(SerialInt{Tag: ns.Tag, Value: ns.Before})</span>
        case 5:<span class="cov8" title="1">
                return cbor.Marshal(SerialInt{Tag: ns.Tag, Value: ns.After})</span>

        default:<span class="cov0" title="0">
                return make([]uint8, 0), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package PlutusData

import (
        "bytes"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "sort"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"

        "github.com/fxamacker/cbor/v2"

        "golang.org/x/crypto/blake2b"
)

type _Script struct {
        _      struct{} `cbor:",toarray"`
        Script []byte
}

type DatumType byte

const (
        DatumTypeHash   DatumType = 0
        DatumTypeInline DatumType = 1
)

type DatumOption struct {
        _         struct{} `cbor:",toarray"`
        DatumType DatumType
        Hash      []byte
        Inline    *PlutusData
}

func (d *DatumOption) UnmarshalCBOR(b []byte) error <span class="cov0" title="0">{
        var cborDatumOption struct {
                _         struct{} `cbor:",toarray"`
                DatumType DatumType
                Content   cbor.RawMessage
        }
        err := cbor.Unmarshal(b, &amp;cborDatumOption)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("DatumOption: UnmarshalCBOR: %v", err)
        }</span>
        <span class="cov0" title="0">if cborDatumOption.DatumType == DatumTypeInline </span><span class="cov0" title="0">{
                var cborDatumInline PlutusData
                errInline := cbor.Unmarshal(cborDatumOption.Content, &amp;cborDatumInline)
                if errInline != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("DatumOption: UnmarshalCBOR: %v", errInline)
                }</span>
                <span class="cov0" title="0">if cborDatumInline.TagNr != 24 </span><span class="cov0" title="0">{
                        return fmt.Errorf("DatumOption: UnmarshalCBOR: DatumTypeInline but Tag was not 24: %v", cborDatumInline.TagNr)
                }</span>
                <span class="cov0" title="0">taggedBytes, valid := cborDatumInline.Value.([]byte)
                if !valid </span><span class="cov0" title="0">{
                        return fmt.Errorf("DatumOption: UnmarshalCBOR: found tag 24 but there wasn't a byte array")
                }</span>
                <span class="cov0" title="0">var inline PlutusData
                err = cbor.Unmarshal(taggedBytes, &amp;inline)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("DatumOption: UnmarshalCBOR: %v", err)
                }</span>
                <span class="cov0" title="0">d.DatumType = DatumTypeInline
                d.Inline = &amp;inline
                return nil</span>
        } else<span class="cov0" title="0"> if cborDatumOption.DatumType == DatumTypeHash </span><span class="cov0" title="0">{
                var cborDatumHash []byte
                errHash := cbor.Unmarshal(cborDatumOption.Content, &amp;cborDatumHash)
                if errHash != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("DatumOption: UnmarshalCBOR: %v", errHash)
                }</span>
                <span class="cov0" title="0">d.DatumType = DatumTypeHash
                d.Hash = cborDatumHash
                return nil</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("DatumOption: UnmarshalCBOR: Unknown tag: %v", cborDatumOption.DatumType)
        }</span>

}

func DatumOptionHash(hash []byte) DatumOption <span class="cov0" title="0">{
        return DatumOption{
                DatumType: DatumTypeHash,
                Hash:      hash,
        }
}</span>

func DatumOptionInline(pd *PlutusData) DatumOption <span class="cov0" title="0">{
        return DatumOption{
                DatumType: DatumTypeInline,
                Inline:    pd,
        }
}</span>

func (d DatumOption) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        var format struct {
                _       struct{} `cbor:",toarray"`
                Tag     DatumType
                Content *PlutusData
        }
        switch d.DatumType </span>{
        case DatumTypeHash:<span class="cov0" title="0">
                format.Tag = DatumTypeHash
                format.Content = &amp;PlutusData{
                        PlutusDataType: PlutusBytes,
                        TagNr:          0,
                        Value:          d.Hash,
                }</span>
        case DatumTypeInline:<span class="cov0" title="0">
                format.Tag = DatumTypeInline
                bytes, err := cbor.Marshal(d.Inline)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("DatumOption: MarshalCBOR(): Failed to marshal inline datum: %v", err)
                }</span>
                <span class="cov0" title="0">format.Content = &amp;PlutusData{
                        PlutusDataType: PlutusBytes,
                        TagNr:          24,
                        Value:          bytes,
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("Invalid DatumOption: %v", d)</span>
        }
        <span class="cov0" title="0">return cbor.Marshal(format)</span>
}

type ScriptRef struct {
        Script _Script
}

type CostModels map[serialization.CustomBytes]CM

type CM map[string]int

/*
*

        MarshalCBOR encodes the CM into a CBOR-encoded byte slice, in which
        it serializes the map key alphabetically and encodes the respective values.

        Returns:
                []byte: The CBOR-encoded byte slice.
                error: An error if marshaling fails.
*/
func (cm CM) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        res := make([]int, 0)
        mk := make([]string, 0)
        for k, _ := range cm </span><span class="cov0" title="0">{
                mk = append(mk, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(mk)
        for _, v := range mk </span><span class="cov0" title="0">{
                res = append(res, cm[v])
        }</span>
        <span class="cov0" title="0">partial, _ := cbor.Marshal(res)
        partial[1] = 0x9f
        partial = append(partial, 0xff)
        return cbor.Marshal(partial[1:])</span>
}

var PLUTUSV1COSTMODEL = CM{
        "addInteger-cpu-arguments-intercept":                       205665,
        "addInteger-cpu-arguments-slope":                           812,
        "addInteger-memory-arguments-intercept":                    1,
        "addInteger-memory-arguments-slope":                        1,
        "appendByteString-cpu-arguments-intercept":                 1000,
        "appendByteString-cpu-arguments-slope":                     571,
        "appendByteString-memory-arguments-intercept":              0,
        "appendByteString-memory-arguments-slope":                  1,
        "appendString-cpu-arguments-intercept":                     1000,
        "appendString-cpu-arguments-slope":                         24177,
        "appendString-memory-arguments-intercept":                  4,
        "appendString-memory-arguments-slope":                      1,
        "bData-cpu-arguments":                                      1000,
        "bData-memory-arguments":                                   32,
        "blake2b_256-cpu-arguments-intercept":                      117366,
        "blake2b_256-cpu-arguments-slope":                          10475,
        "blake2b_256-memory-arguments":                             4,
        "cekApplyCost-exBudgetCPU":                                 23000,
        "cekApplyCost-exBudgetMemory":                              100,
        "cekBuiltinCost-exBudgetCPU":                               23000,
        "cekBuiltinCost-exBudgetMemory":                            100,
        "cekConstCost-exBudgetCPU":                                 23000,
        "cekConstCost-exBudgetMemory":                              100,
        "cekDelayCost-exBudgetCPU":                                 23000,
        "cekDelayCost-exBudgetMemory":                              100,
        "cekForceCost-exBudgetCPU":                                 23000,
        "cekForceCost-exBudgetMemory":                              100,
        "cekLamCost-exBudgetCPU":                                   23000,
        "cekLamCost-exBudgetMemory":                                100,
        "cekStartupCost-exBudgetCPU":                               100,
        "cekStartupCost-exBudgetMemory":                            100,
        "cekVarCost-exBudgetCPU":                                   23000,
        "cekVarCost-exBudgetMemory":                                100,
        "chooseData-cpu-arguments":                                 19537,
        "chooseData-memory-arguments":                              32,
        "chooseList-cpu-arguments":                                 175354,
        "chooseList-memory-arguments":                              32,
        "chooseUnit-cpu-arguments":                                 46417,
        "chooseUnit-memory-arguments":                              4,
        "consByteString-cpu-arguments-intercept":                   221973,
        "consByteString-cpu-arguments-slope":                       511,
        "consByteString-memory-arguments-intercept":                0,
        "consByteString-memory-arguments-slope":                    1,
        "constrData-cpu-arguments":                                 89141,
        "constrData-memory-arguments":                              32,
        "decodeUtf8-cpu-arguments-intercept":                       497525,
        "decodeUtf8-cpu-arguments-slope":                           14068,
        "decodeUtf8-memory-arguments-intercept":                    4,
        "decodeUtf8-memory-arguments-slope":                        2,
        "divideInteger-cpu-arguments-constant":                     196500,
        "divideInteger-cpu-arguments-model-arguments-intercept":    453240,
        "divideInteger-cpu-arguments-model-arguments-slope":        220,
        "divideInteger-memory-arguments-intercept":                 0,
        "divideInteger-memory-arguments-minimum":                   1,
        "divideInteger-memory-arguments-slope":                     1,
        "encodeUtf8-cpu-arguments-intercept":                       1000,
        "encodeUtf8-cpu-arguments-slope":                           28662,
        "encodeUtf8-memory-arguments-intercept":                    4,
        "encodeUtf8-memory-arguments-slope":                        2,
        "equalsByteString-cpu-arguments-constant":                  245000,
        "equalsByteString-cpu-arguments-intercept":                 216773,
        "equalsByteString-cpu-arguments-slope":                     62,
        "equalsByteString-memory-arguments":                        1,
        "equalsData-cpu-arguments-intercept":                       1060367,
        "equalsData-cpu-arguments-slope":                           12586,
        "equalsData-memory-arguments":                              1,
        "equalsInteger-cpu-arguments-intercept":                    208512,
        "equalsInteger-cpu-arguments-slope":                        421,
        "equalsInteger-memory-arguments":                           1,
        "equalsString-cpu-arguments-constant":                      187000,
        "equalsString-cpu-arguments-intercept":                     1000,
        "equalsString-cpu-arguments-slope":                         52998,
        "equalsString-memory-arguments":                            1,
        "fstPair-cpu-arguments":                                    80436,
        "fstPair-memory-arguments":                                 32,
        "headList-cpu-arguments":                                   43249,
        "headList-memory-arguments":                                32,
        "iData-cpu-arguments":                                      1000,
        "iData-memory-arguments":                                   32,
        "ifThenElse-cpu-arguments":                                 80556,
        "ifThenElse-memory-arguments":                              1,
        "indexByteString-cpu-arguments":                            57667,
        "indexByteString-memory-arguments":                         4,
        "lengthOfByteString-cpu-arguments":                         1000,
        "lengthOfByteString-memory-arguments":                      10,
        "lessThanByteString-cpu-arguments-intercept":               197145,
        "lessThanByteString-cpu-arguments-slope":                   156,
        "lessThanByteString-memory-arguments":                      1,
        "lessThanEqualsByteString-cpu-arguments-intercept":         197145,
        "lessThanEqualsByteString-cpu-arguments-slope":             156,
        "lessThanEqualsByteString-memory-arguments":                1,
        "lessThanEqualsInteger-cpu-arguments-intercept":            204924,
        "lessThanEqualsInteger-cpu-arguments-slope":                473,
        "lessThanEqualsInteger-memory-arguments":                   1,
        "lessThanInteger-cpu-arguments-intercept":                  208896,
        "lessThanInteger-cpu-arguments-slope":                      511,
        "lessThanInteger-memory-arguments":                         1,
        "listData-cpu-arguments":                                   52467,
        "listData-memory-arguments":                                32,
        "mapData-cpu-arguments":                                    64832,
        "mapData-memory-arguments":                                 32,
        "mkCons-cpu-arguments":                                     65493,
        "mkCons-memory-arguments":                                  32,
        "mkNilData-cpu-arguments":                                  22558,
        "mkNilData-memory-arguments":                               32,
        "mkNilPairData-cpu-arguments":                              16563,
        "mkNilPairData-memory-arguments":                           32,
        "mkPairData-cpu-arguments":                                 76511,
        "mkPairData-memory-arguments":                              32,
        "modInteger-cpu-arguments-constant":                        196500,
        "modInteger-cpu-arguments-model-arguments-intercept":       453240,
        "modInteger-cpu-arguments-model-arguments-slope":           220,
        "modInteger-memory-arguments-intercept":                    0,
        "modInteger-memory-arguments-minimum":                      1,
        "modInteger-memory-arguments-slope":                        1,
        "multiplyInteger-cpu-arguments-intercept":                  69522,
        "multiplyInteger-cpu-arguments-slope":                      11687,
        "multiplyInteger-memory-arguments-intercept":               0,
        "multiplyInteger-memory-arguments-slope":                   1,
        "nullList-cpu-arguments":                                   60091,
        "nullList-memory-arguments":                                32,
        "quotientInteger-cpu-arguments-constant":                   196500,
        "quotientInteger-cpu-arguments-model-arguments-intercept":  453240,
        "quotientInteger-cpu-arguments-model-arguments-slope":      220,
        "quotientInteger-memory-arguments-intercept":               0,
        "quotientInteger-memory-arguments-minimum":                 1,
        "quotientInteger-memory-arguments-slope":                   1,
        "remainderInteger-cpu-arguments-constant":                  196500,
        "remainderInteger-cpu-arguments-model-arguments-intercept": 453240,
        "remainderInteger-cpu-arguments-model-arguments-slope":     220,
        "remainderInteger-memory-arguments-intercept":              0,
        "remainderInteger-memory-arguments-minimum":                1,
        "remainderInteger-memory-arguments-slope":                  1,
        "sha2_256-cpu-arguments-intercept":                         806990,
        "sha2_256-cpu-arguments-slope":                             30482,
        "sha2_256-memory-arguments":                                4,
        "sha3_256-cpu-arguments-intercept":                         1927926,
        "sha3_256-cpu-arguments-slope":                             82523,
        "sha3_256-memory-arguments":                                4,
        "sliceByteString-cpu-arguments-intercept":                  265318,
        "sliceByteString-cpu-arguments-slope":                      0,
        "sliceByteString-memory-arguments-intercept":               4,
        "sliceByteString-memory-arguments-slope":                   0,
        "sndPair-cpu-arguments":                                    85931,
        "sndPair-memory-arguments":                                 32,
        "subtractInteger-cpu-arguments-intercept":                  205665,
        "subtractInteger-cpu-arguments-slope":                      812,
        "subtractInteger-memory-arguments-intercept":               1,
        "subtractInteger-memory-arguments-slope":                   1,
        "tailList-cpu-arguments":                                   41182,
        "tailList-memory-arguments":                                32,
        "trace-cpu-arguments":                                      212342,
        "trace-memory-arguments":                                   32,
        "unBData-cpu-arguments":                                    31220,
        "unBData-memory-arguments":                                 32,
        "unConstrData-cpu-arguments":                               32696,
        "unConstrData-memory-arguments":                            32,
        "unIData-cpu-arguments":                                    43357,
        "unIData-memory-arguments":                                 32,
        "unListData-cpu-arguments":                                 32247,
        "unListData-memory-arguments":                              32,
        "unMapData-cpu-arguments":                                  38314,
        "unMapData-memory-arguments":                               32,
        "verifyEd25519Signature-cpu-arguments-intercept":           57996947,
        "verifyEd25519Signature-cpu-arguments-slope":               18975,
        "verifyEd25519Signature-memory-arguments":                  10,
}

type CostView map[string]int

/*
*

        MarshalCBOR encodes the CostView into a CBOR-encoded byte slice, in which
        it serializes the map key alphabetically and encodes the respective values.

        Returns:
                []byte: The CBOR-encoded byte slice.
                error: An error if marshaling fails.
*/
func (cm CostView) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        res := make([]int, 0)
        mk := make([]string, 0)
        for k, _ := range cm </span><span class="cov0" title="0">{
                mk = append(mk, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(mk)
        for _, v := range mk </span><span class="cov0" title="0">{
                res = append(res, cm[v])
        }</span>
        <span class="cov0" title="0">return cbor.Marshal(res)</span>

}

var PLUTUSV2COSTMODEL = CostView{
        "addInteger-cpu-arguments-intercept":                       205665,
        "addInteger-cpu-arguments-slope":                           812,
        "addInteger-memory-arguments-intercept":                    1,
        "addInteger-memory-arguments-slope":                        1,
        "appendByteString-cpu-arguments-intercept":                 1000,
        "appendByteString-cpu-arguments-slope":                     571,
        "appendByteString-memory-arguments-intercept":              0,
        "appendByteString-memory-arguments-slope":                  1,
        "appendString-cpu-arguments-intercept":                     1000,
        "appendString-cpu-arguments-slope":                         24177,
        "appendString-memory-arguments-intercept":                  4,
        "appendString-memory-arguments-slope":                      1,
        "bData-cpu-arguments":                                      1000,
        "bData-memory-arguments":                                   32,
        "blake2b_256-cpu-arguments-intercept":                      117366,
        "blake2b_256-cpu-arguments-slope":                          10475,
        "blake2b_256-memory-arguments":                             4,
        "cekApplyCost-exBudgetCPU":                                 23000,
        "cekApplyCost-exBudgetMemory":                              100,
        "cekBuiltinCost-exBudgetCPU":                               23000,
        "cekBuiltinCost-exBudgetMemory":                            100,
        "cekConstCost-exBudgetCPU":                                 23000,
        "cekConstCost-exBudgetMemory":                              100,
        "cekDelayCost-exBudgetCPU":                                 23000,
        "cekDelayCost-exBudgetMemory":                              100,
        "cekForceCost-exBudgetCPU":                                 23000,
        "cekForceCost-exBudgetMemory":                              100,
        "cekLamCost-exBudgetCPU":                                   23000,
        "cekLamCost-exBudgetMemory":                                100,
        "cekStartupCost-exBudgetCPU":                               100,
        "cekStartupCost-exBudgetMemory":                            100,
        "cekVarCost-exBudgetCPU":                                   23000,
        "cekVarCost-exBudgetMemory":                                100,
        "chooseData-cpu-arguments":                                 19537,
        "chooseData-memory-arguments":                              32,
        "chooseList-cpu-arguments":                                 175354,
        "chooseList-memory-arguments":                              32,
        "chooseUnit-cpu-arguments":                                 46417,
        "chooseUnit-memory-arguments":                              4,
        "consByteString-cpu-arguments-intercept":                   221973,
        "consByteString-cpu-arguments-slope":                       511,
        "consByteString-memory-arguments-intercept":                0,
        "consByteString-memory-arguments-slope":                    1,
        "constrData-cpu-arguments":                                 89141,
        "constrData-memory-arguments":                              32,
        "decodeUtf8-cpu-arguments-intercept":                       497525,
        "decodeUtf8-cpu-arguments-slope":                           14068,
        "decodeUtf8-memory-arguments-intercept":                    4,
        "decodeUtf8-memory-arguments-slope":                        2,
        "divideInteger-cpu-arguments-constant":                     196500,
        "divideInteger-cpu-arguments-model-arguments-intercept":    453240,
        "divideInteger-cpu-arguments-model-arguments-slope":        220,
        "divideInteger-memory-arguments-intercept":                 0,
        "divideInteger-memory-arguments-minimum":                   1,
        "divideInteger-memory-arguments-slope":                     1,
        "encodeUtf8-cpu-arguments-intercept":                       1000,
        "encodeUtf8-cpu-arguments-slope":                           28662,
        "encodeUtf8-memory-arguments-intercept":                    4,
        "encodeUtf8-memory-arguments-slope":                        2,
        "equalsByteString-cpu-arguments-constant":                  245000,
        "equalsByteString-cpu-arguments-intercept":                 216773,
        "equalsByteString-cpu-arguments-slope":                     62,
        "equalsByteString-memory-arguments":                        1,
        "equalsData-cpu-arguments-intercept":                       1060367,
        "equalsData-cpu-arguments-slope":                           12586,
        "equalsData-memory-arguments":                              1,
        "equalsInteger-cpu-arguments-intercept":                    208512,
        "equalsInteger-cpu-arguments-slope":                        421,
        "equalsInteger-memory-arguments":                           1,
        "equalsString-cpu-arguments-constant":                      187000,
        "equalsString-cpu-arguments-intercept":                     1000,
        "equalsString-cpu-arguments-slope":                         52998,
        "equalsString-memory-arguments":                            1,
        "fstPair-cpu-arguments":                                    80436,
        "fstPair-memory-arguments":                                 32,
        "headList-cpu-arguments":                                   43249,
        "headList-memory-arguments":                                32,
        "iData-cpu-arguments":                                      1000,
        "iData-memory-arguments":                                   32,
        "ifThenElse-cpu-arguments":                                 80556,
        "ifThenElse-memory-arguments":                              1,
        "indexByteString-cpu-arguments":                            57667,
        "indexByteString-memory-arguments":                         4,
        "lengthOfByteString-cpu-arguments":                         1000,
        "lengthOfByteString-memory-arguments":                      10,
        "lessThanByteString-cpu-arguments-intercept":               197145,
        "lessThanByteString-cpu-arguments-slope":                   156,
        "lessThanByteString-memory-arguments":                      1,
        "lessThanEqualsByteString-cpu-arguments-intercept":         197145,
        "lessThanEqualsByteString-cpu-arguments-slope":             156,
        "lessThanEqualsByteString-memory-arguments":                1,
        "lessThanEqualsInteger-cpu-arguments-intercept":            204924,
        "lessThanEqualsInteger-cpu-arguments-slope":                473,
        "lessThanEqualsInteger-memory-arguments":                   1,
        "lessThanInteger-cpu-arguments-intercept":                  208896,
        "lessThanInteger-cpu-arguments-slope":                      511,
        "lessThanInteger-memory-arguments":                         1,
        "listData-cpu-arguments":                                   52467,
        "listData-memory-arguments":                                32,
        "mapData-cpu-arguments":                                    64832,
        "mapData-memory-arguments":                                 32,
        "mkCons-cpu-arguments":                                     65493,
        "mkCons-memory-arguments":                                  32,
        "mkNilData-cpu-arguments":                                  22558,
        "mkNilData-memory-arguments":                               32,
        "mkNilPairData-cpu-arguments":                              16563,
        "mkNilPairData-memory-arguments":                           32,
        "mkPairData-cpu-arguments":                                 76511,
        "mkPairData-memory-arguments":                              32,
        "modInteger-cpu-arguments-constant":                        196500,
        "modInteger-cpu-arguments-model-arguments-intercept":       453240,
        "modInteger-cpu-arguments-model-arguments-slope":           220,
        "modInteger-memory-arguments-intercept":                    0,
        "modInteger-memory-arguments-minimum":                      1,
        "modInteger-memory-arguments-slope":                        1,
        "multiplyInteger-cpu-arguments-intercept":                  69522,
        "multiplyInteger-cpu-arguments-slope":                      11687,
        "multiplyInteger-memory-arguments-intercept":               0,
        "multiplyInteger-memory-arguments-slope":                   1,
        "nullList-cpu-arguments":                                   60091,
        "nullList-memory-arguments":                                32,
        "quotientInteger-cpu-arguments-constant":                   196500,
        "quotientInteger-cpu-arguments-model-arguments-intercept":  453240,
        "quotientInteger-cpu-arguments-model-arguments-slope":      220,
        "quotientInteger-memory-arguments-intercept":               0,
        "quotientInteger-memory-arguments-minimum":                 1,
        "quotientInteger-memory-arguments-slope":                   1,
        "remainderInteger-cpu-arguments-constant":                  196500,
        "remainderInteger-cpu-arguments-model-arguments-intercept": 453240,
        "remainderInteger-cpu-arguments-model-arguments-slope":     220,
        "remainderInteger-memory-arguments-intercept":              0,
        "remainderInteger-memory-arguments-minimum":                1,
        "remainderInteger-memory-arguments-slope":                  1,
        "serialiseData-cpu-arguments-intercept":                    1159724,
        "serialiseData-cpu-arguments-slope":                        392670,
        "serialiseData-memory-arguments-intercept":                 0,
        "serialiseData-memory-arguments-slope":                     2,
        "sha2_256-cpu-arguments-intercept":                         806990,
        "sha2_256-cpu-arguments-slope":                             30482,
        "sha2_256-memory-arguments":                                4,
        "sha3_256-cpu-arguments-intercept":                         1927926,
        "sha3_256-cpu-arguments-slope":                             82523,
        "sha3_256-memory-arguments":                                4,
        "sliceByteString-cpu-arguments-intercept":                  265318,
        "sliceByteString-cpu-arguments-slope":                      0,
        "sliceByteString-memory-arguments-intercept":               4,
        "sliceByteString-memory-arguments-slope":                   0,
        "sndPair-cpu-arguments":                                    85931,
        "sndPair-memory-arguments":                                 32,
        "subtractInteger-cpu-arguments-intercept":                  205665,
        "subtractInteger-cpu-arguments-slope":                      812,
        "subtractInteger-memory-arguments-intercept":               1,
        "subtractInteger-memory-arguments-slope":                   1,
        "tailList-cpu-arguments":                                   41182,
        "tailList-memory-arguments":                                32,
        "trace-cpu-arguments":                                      212342,
        "trace-memory-arguments":                                   32,
        "unBData-cpu-arguments":                                    31220,
        "unBData-memory-arguments":                                 32,
        "unConstrData-cpu-arguments":                               32696,
        "unConstrData-memory-arguments":                            32,
        "unIData-cpu-arguments":                                    43357,
        "unIData-memory-arguments":                                 32,
        "unListData-cpu-arguments":                                 32247,
        "unListData-memory-arguments":                              32,
        "unMapData-cpu-arguments":                                  38314,
        "unMapData-memory-arguments":                               32,
        "verifyEcdsaSecp256k1Signature-cpu-arguments":              35892428,
        "verifyEcdsaSecp256k1Signature-memory-arguments":           10,
        "verifyEd25519Signature-cpu-arguments-intercept":           57996947,
        "verifyEd25519Signature-cpu-arguments-slope":               18975,
        "verifyEd25519Signature-memory-arguments":                  10,
        "verifySchnorrSecp256k1Signature-cpu-arguments-intercept":  38887044,
        "verifySchnorrSecp256k1Signature-cpu-arguments-slope":      32947,
        "verifySchnorrSecp256k1Signature-memory-arguments":         10,
}

var COST_MODELSV2 = map[int]cbor.Marshaler{1: PLUTUSV2COSTMODEL}
var COST_MODELSV1 = map[serialization.CustomBytes]cbor.Marshaler{{Value: "00"}: PLUTUSV1COSTMODEL}

type PlutusType int

const (
        PlutusArray PlutusType = iota
        PlutusMap
        PlutusInt
        PlutusBytes
        PlutusShortArray
)

type PlutusList interface {
        Len() int
}

type PlutusIndefArray []PlutusData
type PlutusDefArray []PlutusData

/*
*

        Len returns the length of the PlutusIndefArray.

        Returns:
                int: The length of the PlutusIndefArray.
*/
func (pia PlutusIndefArray) Len() int <span class="cov0" title="0">{
        return len(pia)
}</span>

/*
*

        Len returns the length of the PlutusDefArray.

        Returns:
                int: The length of the PlutusDefArray.
*/
func (pia PlutusDefArray) Len() int <span class="cov0" title="0">{
        return len(pia)
}</span>

/*
*

        Clone creates a deep copy of the PlutusIndefArray.

        Returns:
                PlutusIndefArray: A deep copy of the PlutusIndefArray.
*/
func (pia *PlutusIndefArray) Clone() PlutusIndefArray <span class="cov0" title="0">{
        var ret PlutusIndefArray
        for _, v := range *pia </span><span class="cov0" title="0">{
                ret = append(ret, v.Clone())
        }</span>
        <span class="cov0" title="0">return ret</span>
}

/*
*

                MarshalCBOR encodes the PlutusIndefArray into a CBOR-encoded byte
                slice, in which it serializes the elements in indefinite-length array format.

                Returns:
                           []uint8: The CBOR-encoded byte slice.
                           error: An error if marshaling fails.
*/
func (pia PlutusIndefArray) MarshalCBOR() ([]uint8, error) <span class="cov8" title="1">{
        res := make([]byte, 0)
        res = append(res, 0x9f)

        for _, el := range pia </span><span class="cov8" title="1">{
                bytes, err := cbor.Marshal(el)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">res = append(res, bytes...)</span>
        }
        <span class="cov8" title="1">res = append(res, 0xff)
        return res, nil</span>
}

type Datum struct {
        PlutusDataType PlutusType
        TagNr          uint64
        Value          any
}

/*
*

        ToPlutusData converts a datum to PlutusData, encoding
        the Datum into CBOR format and then decodes it into a
        PlutusData.

        Returns:
                PlutusData: The converted PlutusData.
*/
func (pd *Datum) ToPlutusData() PlutusData <span class="cov0" title="0">{
        var res PlutusData
        enc, _ := cbor.Marshal(pd)
        cbor.Unmarshal(enc, &amp;res)
        return res
}</span>

/*
*

        Clone creates a deep copy of the Datum&gt;

        Returns:
                Datum: A deep copy of the Datum
*/
func (pd *Datum) Clone() Datum <span class="cov0" title="0">{
        return Datum{
                PlutusDataType: pd.PlutusDataType,
                TagNr:          pd.TagNr,
                Value:          pd.Value,
        }
}</span>

/*
*

                MarshalCBOR encodes the Datum into a CBOR-encoded byte slice,
                it applies a CBOR tag, if TagNr is not 0, otherwise it marshals the Value

                Returns:
                           []uint8: The CBOR-encoded byte slice.
                           error: An error if marshaling fails.
*/
func (pd Datum) MarshalCBOR() ([]uint8, error) <span class="cov0" title="0">{
        if pd.TagNr == 0 </span><span class="cov0" title="0">{
                return cbor.Marshal(pd.Value)
        }</span> else<span class="cov0" title="0"> {
                return cbor.Marshal(cbor.Tag{Number: pd.TagNr, Content: pd.Value})
        }</span>
}

/*
*

                UnmarshalCBOR decodes a CBOR-encoded byte slice into a Datum.
                It handles different Plutus data types and applies appropriate decoding logic.

                Returns:
                           error: An error if unmarshaling fails.
*/
func (pd *Datum) UnmarshalCBOR(value []uint8) error <span class="cov0" title="0">{
        var x any
        err := cbor.Unmarshal(value, &amp;x)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ok, valid := x.(cbor.Tag)
        if valid </span><span class="cov0" title="0">{
                switch ok.Content.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        pd.TagNr = ok.Number
                        pd.PlutusDataType = PlutusArray
                        res, err := cbor.Marshal(ok.Content)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">y := new([]Datum)
                        err = cbor.Unmarshal(res, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.Value = y</span>

                default:<span class="cov0" title="0">
                        //TODO SKIP
                        return nil</span>
                }
        } else<span class="cov0" title="0"> {
                switch x.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        y := new([]Datum)
                        err = cbor.Unmarshal(value, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.PlutusDataType = PlutusArray
                        pd.Value = y
                        pd.TagNr = 0</span>
                case uint64:<span class="cov0" title="0">
                        pd.PlutusDataType = PlutusInt
                        pd.Value = x
                        pd.TagNr = 0</span>

                case []uint8:<span class="cov0" title="0">
                        pd.PlutusDataType = PlutusBytes
                        pd.Value = x
                        pd.TagNr = 0</span>

                case map[interface{}]interface{}:<span class="cov0" title="0">
                        y := new(map[serialization.CustomBytes]Datum)
                        err = cbor.Unmarshal(value, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.PlutusDataType = PlutusMap
                        pd.Value = y
                        pd.TagNr = 0</span>

                default:<span class="cov0" title="0"></span>
                }

        }

        <span class="cov0" title="0">return nil</span>
}

type PlutusData struct {
        PlutusDataType PlutusType
        TagNr          uint64
        Value          any
}

/*
*

        Equal check if two PlutusData values are equal
        using their CBOR representations.

        Params:
                other (PlutusData): The other PlutusData to compare to.

        Returns:
                bool: True if the PlutusData are equal, false otherwise.
*/
func (pd *PlutusData) Equal(other PlutusData) bool <span class="cov0" title="0">{
        marshaledThis, _ := cbor.Marshal(pd)
        marshaledOther, _ := cbor.Marshal(other)
        return bytes.Equal(marshaledThis, marshaledOther)
}</span>

/*
*

        ToDatum converts a PlutusData to a Datum, in which
        it encodes the PlutusData into CBOR format and later
        into a Datum.

        Returns:
                Datum: The converted Datum.
*/
func (pd *PlutusData) ToDatum() Datum <span class="cov0" title="0">{

        var res Datum
        enc, _ := cbor.Marshal(pd)
        cbor.Unmarshal(enc, &amp;res)
        return res
}</span>

/*
*

        Clone creates a deep copy of a PlutusData object.

        Returns:
                PlutusData: A cloned PlutusData object.
*/
func (pd *PlutusData) Clone() PlutusData <span class="cov0" title="0">{
        return PlutusData{
                PlutusDataType: pd.PlutusDataType,
                TagNr:          pd.TagNr,
                Value:          pd.Value,
        }
}</span>

/*
*

        MarshalCBOR encodes the PlutusData into a CBOR byte slice.

        Returns:
                []uint8: The CBOR-encoded byte slice.
                error: An error, if any, during ecoding.
*/
func (pd *PlutusData) MarshalCBOR() ([]uint8, error) <span class="cov8" title="1">{
        if pd.TagNr == 0 </span><span class="cov8" title="1">{
                return cbor.Marshal(pd.Value)
        }</span> else<span class="cov8" title="1"> {
                return cbor.Marshal(cbor.Tag{Number: pd.TagNr, Content: pd.Value})
        }</span>
}

/*
*

                UnmarshalJSON unmarshals JSON-encoded PlutusData into a PlutusData object.

                Params:
                           value ([]byte): The JSON-encoded data to unmarshal.

                 Returns:
                           error: An error, if any, during unmarshaling.
*/
func (pd *PlutusData) UnmarshalJSON(value []byte) error <span class="cov8" title="1">{
        var x any
        err := json.Unmarshal(value, &amp;x)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch x.(type) </span>{
        case []interface{}:<span class="cov8" title="1">
                y := new([]PlutusData)
                err = json.Unmarshal(value, y)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">pd.PlutusDataType = PlutusArray
                pd.Value = PlutusIndefArray(*y)
                pd.TagNr = 0</span>
        case map[string]interface{}:<span class="cov8" title="1">
                val := x.(map[string]interface{})
                _, ok := val["fields"]
                if ok </span><span class="cov8" title="1">{
                        contents, _ := json.Marshal(val["fields"])
                        var tag int
                        constructor, ok := val["constructor"]
                        if ok </span><span class="cov8" title="1">{
                                tag = int(121 + constructor.(float64))
                        }</span> else<span class="cov8" title="1"> {
                                tag = 0
                        }</span>
                        <span class="cov8" title="1">y := new(PlutusData)
                        err = json.Unmarshal(contents, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">pd.PlutusDataType = PlutusMap
                        pd.Value = y
                        pd.TagNr = uint64(tag)</span>
                } else<span class="cov8" title="1"> if _, ok := val["bytes"]; ok </span><span class="cov8" title="1">{
                        pd.PlutusDataType = PlutusBytes
                        pd.Value, _ = hex.DecodeString(val["bytes"].(string))
                }</span> else<span class="cov8" title="1"> if _, ok := val["int"]; ok </span><span class="cov8" title="1">{
                        pd.PlutusDataType = PlutusInt
                        pd.Value = uint64(val["int"].(float64))
                }</span> else<span class="cov0" title="0"> {
                        return errors.New("invalid Nested Struct in plutus data")
                }</span>

        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

                UnmarshalCBOR unmarshals CBOR-encoded data into a PlutusData object.

                Params:
                           value ([]uint8): The CBOR-encoded data to unmarshal.

                 Returns:
                           error: An error, if any, during unmarshaling.
*/
func (pd *PlutusData) UnmarshalCBOR(value []uint8) error <span class="cov8" title="1">{
        var x any
        err := cbor.Unmarshal(value, &amp;x)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ok, valid := x.(cbor.Tag)
        if valid </span><span class="cov8" title="1">{
                switch ok.Content.(type) </span>{
                case []interface{}:<span class="cov8" title="1">
                        pd.TagNr = ok.Number
                        pd.PlutusDataType = PlutusArray
                        if value[2] == 0x9f </span><span class="cov8" title="1">{
                                y := PlutusIndefArray{}
                                err = cbor.Unmarshal(value[2:], &amp;y)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">pd.Value = y</span>
                        } else<span class="cov8" title="1"> {
                                y := PlutusDefArray{}
                                err = cbor.Unmarshal(value[2:], &amp;y)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">pd.Value = y</span>
                        }
                case []uint8:<span class="cov0" title="0">
                        pd.TagNr = ok.Number
                        pd.PlutusDataType = PlutusBytes
                        pd.Value = ok.Content</span>
                case map[interface{}]interface{}:<span class="cov0" title="0">
                        y := new(map[serialization.CustomBytes]PlutusData)
                        err = cbor.Unmarshal(value, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.PlutusDataType = PlutusMap
                        pd.Value = y
                        pd.TagNr = 0</span>

                default:<span class="cov0" title="0">
                        //TODO SKIP
                        fmt.Println("HERE")
                        return nil</span>
                }
        } else<span class="cov8" title="1"> {
                switch x.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        if value[0] == 0x9f </span><span class="cov0" title="0">{
                                y := PlutusIndefArray{}
                                err = cbor.Unmarshal(value, &amp;y)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">pd.PlutusDataType = PlutusArray
                                pd.Value = y
                                pd.TagNr = 0</span>
                        } else<span class="cov0" title="0"> {
                                y := PlutusDefArray{}
                                err = cbor.Unmarshal(value, &amp;y)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">pd.PlutusDataType = PlutusArray
                                pd.Value = y
                                pd.TagNr = 0</span>
                        }
                case uint64:<span class="cov8" title="1">
                        pd.PlutusDataType = PlutusInt
                        pd.Value = x
                        pd.TagNr = 0</span>

                case []uint8:<span class="cov8" title="1">
                        pd.PlutusDataType = PlutusBytes
                        pd.Value = x
                        pd.TagNr = 0</span>

                case map[interface{}]interface{}:<span class="cov0" title="0">
                        y := new(map[serialization.CustomBytes]PlutusData)
                        err = cbor.Unmarshal(value, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.PlutusDataType = PlutusMap
                        pd.Value = y
                        pd.TagNr = 0</span>

                default:<span class="cov0" title="0">
                        fmt.Errorf("Invalid Nested Struct in plutus data %s", reflect.TypeOf(x))</span>
                }

        }

        <span class="cov8" title="1">return nil</span>
}

type RawPlutusData struct {
        //TODO
}

/*
*

        ToCbor converts the given interface to a hexadecimal-encoded CBOR string.

        Params:
                x (interface{}): The input value to be encoded to CBOR to converted
                                                 to a hexadecimal string.

        Returns:
                string: The hexadecimal-encoded CBOR representation of the input value.
                error: An error if the convertion fails.
*/
func ToCbor(x interface{}) (string, error) <span class="cov0" title="0">{
        bytes, err := cbor.Marshal(x)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

/*
*

                PlutusDataHash computes the hash of a PlutusData structure using the Blake2b algorithm.

                 Params:
                           pd (*PlutusData): A pointer to the PlutusData structure to be hashed.

                Returns:
                          serialization.DatumHash: The hash of the PlutusData.
                        error: An error if the PlutusDataHash fails.
*/
func PlutusDataHash(pd *PlutusData) (serialization.DatumHash, error) <span class="cov0" title="0">{
        finalbytes := []byte{}
        bytes, err := cbor.Marshal(pd)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, bytes...)
        hash, err := blake2b.New(32, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.DatumHash{hash.Sum(nil)}
        return r, nil</span>
}

/*
*

        HashDatum computes the hash of a CBOR marshaler using the Blake2b algorithm.

        Params:
                d (cbor.Marshaler): The CBOR marshaler to be hashed

        Returns:
                serialization.DatumHash: The hash of the CBOR marshaler.
                error: An error if the hash Datum fails.
*/
func HashDatum(d cbor.Marshaler) (serialization.DatumHash, error) <span class="cov0" title="0">{
        finalbytes := []byte{}
        bytes, err := cbor.Marshal(d)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, bytes...)
        hash, err := blake2b.New(32, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.DatumHash{hash.Sum(nil)}
        return r, nil</span>
}

type ScriptHashable interface {
        Hash() (serialization.ScriptHash, error)
}

/*
*

        PlutusScriptHash computes the script hash of a ScriptHashable object.

        Params:
                script (ScriptHashable): The ScriptHashable object to be hashed.

        Returns:
                serialization.ScriptHash: The script hash of the ScriptHashable object.
*/
func PlutusScriptHash(script ScriptHashable) serialization.ScriptHash <span class="cov0" title="0">{
        hash, _ := script.Hash()
        return hash
}</span>

type PlutusV1Script []byte

/*
*

                ToAddress converts a PlutusV1Script to an Address with an optional staking credential.

                 Params:
                           stakingCredential ([]byte): The staking credential to include in the address.

                 Returns:
                           Address.Address: The generated address.
*/
func (ps *PlutusV1Script) ToAddress(stakingCredential []byte) Address.Address <span class="cov0" title="0">{
        hash := PlutusScriptHash(ps)
        if stakingCredential == nil </span><span class="cov0" title="0">{
                return Address.Address{hash.Bytes(), nil, Address.MAINNET, Address.SCRIPT_NONE, 0b01110001, "addr"}
        }</span> else<span class="cov0" title="0"> {
                return Address.Address{
                        PaymentPart: hash.Bytes(),
                        StakingPart: stakingCredential,
                        Network:     Address.MAINNET,
                        AddressType: Address.SCRIPT_KEY,
                        HeaderByte:  0b00010001,
                        Hrp:         "addr",
                }
        }</span>
}

type PlutusV2Script []byte

/*
*

                ToAddress converts a PlutusV2Script to an Address with an optional staking credential.

                 Params:
                           stakingCredential ([]byte): The staking credential to include in the address.

                 Returns:
                           Address.Address: The generated address.
*/
func (ps *PlutusV2Script) ToAddress(stakingCredential []byte) Address.Address <span class="cov0" title="0">{
        hash := PlutusScriptHash(ps)
        if stakingCredential == nil </span><span class="cov0" title="0">{
                return Address.Address{hash.Bytes(), nil, Address.MAINNET, Address.SCRIPT_NONE, 0b01110001, "addr"}
        }</span> else<span class="cov0" title="0"> {
                return Address.Address{
                        PaymentPart: hash.Bytes(),
                        StakingPart: stakingCredential,
                        Network:     Address.MAINNET,
                        AddressType: Address.SCRIPT_KEY,
                        HeaderByte:  0b00010001,
                        Hrp:         "addr",
                }
        }</span>
}

/*
*

                 Hash computes the script hash for a PlutusV1Script.

                 Returns:
                           serialization.ScriptHash: The script hash of the PlutusV1Script.
                        error: An error if the hashing fails.
*/
func (ps PlutusV1Script) Hash() (serialization.ScriptHash, error) <span class="cov0" title="0">{
        finalbytes, err := hex.DecodeString("01")
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, ps...)
        hash, err := blake2b.New(28, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.ScriptHash{}
        copy(r[:], hash.Sum(nil))
        return r, nil</span>
}

/*
*

                 Hash computes the script hash for a PlutusV2Script.

                 Returns:
                           serialization.ScriptHash: The script hash of the PlutusV2Script.
                        error: An error if the Hashing fails.
*/
func (ps PlutusV2Script) Hash() (serialization.ScriptHash, error) <span class="cov0" title="0">{
        finalbytes, err := hex.DecodeString("02")
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, ps...)
        hash, err := blake2b.New(28, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.ScriptHash{}
        copy(r[:], hash.Sum(nil))
        return r, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package Policy

import (
        "encoding/hex"
        "errors"

        "github.com/fxamacker/cbor/v2"
)

type PolicyId struct {
        Value string
}

/*
*

        New creates a new PolicyId from a hexadecimal string

        Params:
                value string: The hexadecimal string representing the policy ID.

        Returns:
                *PolicyId: A pointer to the PolicyId.
                error: An error if the input string is not of the expected length.
*/
func New(value string) (*PolicyId, error) <span class="cov8" title="1">{
        if len(value) != 56 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid length of a policy id")
        }</span>
        <span class="cov0" title="0">return &amp;PolicyId{
                Value: value,
        }, nil</span>
}

/*
*

        FromBytes creates a new PolicyId from a byte slice.

        Params:
                value []byte: The byte slice representing the policy ID.

        Returns:
                *PolicyId: A pointer to the PolicyId.
                error: An error if the input byte slice is not of the expected length.
*/
func FromBytes(value []byte) (*PolicyId, error) <span class="cov8" title="1">{
        if len(value) != 28 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid length of a policy id")
        }</span>
        <span class="cov0" title="0">return &amp;PolicyId{
                Value: hex.EncodeToString(value),
        }, nil</span>
}

/*
*

        String returns the hexadecimal string representation
        of the PolicyId.
*/
func (policyId PolicyId) String() string <span class="cov8" title="1">{
        return policyId.Value
}</span>

/*
*

        MarshalCBOR serializes the PolicyId to CBOR format.

        Returns:
                []byte: The CBOR serialized data.
                error: An error if the serialization fails.
*/
func (policyId *PolicyId) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        res, err := hex.DecodeString(policyId.Value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(res) != 28 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid length of a policy id")
        }</span>

        <span class="cov8" title="1">if len(res) == 0 </span><span class="cov0" title="0">{
                return cbor.Marshal(make([]byte, 0))
        }</span>
        <span class="cov8" title="1">return cbor.Marshal(res)</span>

}

/*
*

        UnmarshalCBOR deserializes the PolicyId from CBOR format.

        Params:
                value []byte: The CBOR serialized data.

        Returns:
                error: An error if the deserialization fails.
*/
func (policyId *PolicyId) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var res any
        err := cbor.Unmarshal(value, &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch res := res.(type) </span>{
        case []byte:<span class="cov8" title="1">
                hexString := hex.EncodeToString(res)
                if len(hexString) != 56 </span><span class="cov0" title="0">{
                        return errors.New("invalid length of a policy id")
                }</span>
                <span class="cov8" title="1">policyId.Value = hexString</span>
        case string:<span class="cov0" title="0">
                hexString := res
                if len(hexString) != 56 </span><span class="cov0" title="0">{
                        return errors.New("invalid length of a policy id")
                }</span>
                <span class="cov0" title="0">policyId.Value = hexString</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid type of a policy id")</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package Redeemer

import "github.com/Salvionied/apollo/serialization/PlutusData"

type RedeemerTag int

const (
        SPEND RedeemerTag = iota
        MINT
        CERT
        REWARD
)

// See https://ogmios.dev/mini-protocols/local-tx-submission/#evaluatetx
var RdeemerTagNames = map[RedeemerTag]string{
        0: "spend",
        1: "mint",
        2: "certificate",
        3: "withdrawal",
}

type ExecutionUnits struct {
        _     struct{} `cbor:",toarray"`
        Mem   int64
        Steps int64
}

/**
        Clone creates a deep copy of the ExecutionUnits.

        Returns:
                ExecutionUnits: A new ExecutionUnits instance with the same values.
*/
func (ex *ExecutionUnits) Clone() ExecutionUnits <span class="cov8" title="1">{
        return ExecutionUnits{
                Mem:   ex.Mem,
                Steps: ex.Steps,
        }
}</span>

/**
        Sum adds the memory and step of another ExecutionUnits to
        the current instance.

        Params:
                other ExecutionUnits: The ExecutionUnits to add.
*/
func (eu *ExecutionUnits) Sum(other ExecutionUnits) <span class="cov8" title="1">{
        eu.Mem += other.Mem
        eu.Steps += other.Steps
}</span>

// TODO
type Redeemer struct {
        _       struct{} `cbor:",toarray"`
        Tag     RedeemerTag
        Index   int
        Data    PlutusData.PlutusData
        ExUnits ExecutionUnits
}

/**
        Clone creates a deep copy of the Redeemer.

        Returns:
                Redeemer: A new Redeemer instance with the same values.
*/
func (r Redeemer) Clone() Redeemer <span class="cov8" title="1">{
        return Redeemer{
                Tag:     r.Tag,
                Index:   r.Index,
                Data:    r.Data.Clone(),
                ExUnits: r.ExUnits.Clone(),
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package Transaction

import (
        "fmt"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Metadata"
        "github.com/Salvionied/apollo/serialization/TransactionBody"
        "github.com/Salvionied/apollo/serialization/TransactionWitnessSet"
        "github.com/fxamacker/cbor/v2"
)

type Transaction struct {
        _                     struct{} `cbor:",toarray"`
        TransactionBody       TransactionBody.TransactionBody
        TransactionWitnessSet TransactionWitnessSet.TransactionWitnessSet
        Valid                 bool
        AuxiliaryData         *Metadata.AuxiliaryData
}


/**
        Bytes returns the CBOR-encoded byte representation
        of the Transaction.

        Returns:
                []byte: The CBOR-encoded transaction bytes.
                error: An error if the Bytes fails.
*/
func (tx *Transaction) Bytes() ([]byte, error) <span class="cov8" title="1">{
        cborred, err := cbor.Marshal(tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshaling transaction, %s", err)
        }</span>
        <span class="cov8" title="1">return cborred, nil</span>
}

/**
        Id returns the unique identifier for the transaction.

        Returns:
                serialization.TransactionId: The transaction ID.
*/
func (tx *Transaction) Id() serialization.TransactionId <span class="cov8" title="1">{
        txId, _ := tx.TransactionBody.Id()
        return txId
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package TransactionBody

import (
        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Certificate"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/Withdrawal"

        "github.com/fxamacker/cbor/v2"
        "golang.org/x/crypto/blake2b"
)

type TransactionBody struct {
        Inputs            []TransactionInput.TransactionInput   `cbor:"0,keyasint"`
        Outputs           []TransactionOutput.TransactionOutput `cbor:"1,keyasint"`
        Fee               int64                                 `cbor:"2,keyasint"`
        Ttl               int64                                 `cbor:"3,keyasint,omitempty"`
        Certificates      *Certificate.Certificates             `cbor:"4,keyasint,omitempty"`
        Withdrawals       *Withdrawal.Withdrawal                `cbor:"5,keyasint,omitempty"`
        UpdateProposals   []any                                 `cbor:"6,keyasint,omitempty"`
        AuxiliaryDataHash []byte                                `cbor:"7,keyasint,omitempty"`
        ValidityStart     int64                                 `cbor:"8,keyasint,omitempty"`
        Mint              MultiAsset.MultiAsset[int64]          `cbor:"9,keyasint,omitempty"`
        ScriptDataHash    []byte                                `cbor:"11,keyasint,omitempty"`
        Collateral        []TransactionInput.TransactionInput   `cbor:"13,keyasint,omitempty"`
        RequiredSigners   []serialization.PubKeyHash            `cbor:"14,keyasint,omitempty"`
        NetworkId         []byte                                `cbor:"15,keyasint,omitempty"`
        CollateralReturn  *TransactionOutput.TransactionOutput  `cbor:"16,keyasint,omitempty"`
        TotalCollateral   int                                   `cbor:"17,keyasint,omitempty"`
        ReferenceInputs   []TransactionInput.TransactionInput   `cbor:"18,keyasint,omitempty"`
}

func (tx *TransactionBody) Hash() ([]byte, error) <span class="cov8" title="1">{
        bytes, err := cbor.Marshal(tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">hash, err := blake2b.New(32, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, err = hash.Write(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return hash.Sum(nil), nil</span>

}

func (tx *TransactionBody) Id() (serialization.TransactionId, error) <span class="cov8" title="1">{
        bytes, err := tx.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return serialization.TransactionId{}, err
        }</span>
        <span class="cov8" title="1">return serialization.TransactionId{bytes}, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package TransactionInput

import (
        "bytes"
        "encoding/hex"
        "strconv"
)

type TransactionInput struct {
        _             struct{} `cbor:",toarray"`
        TransactionId []byte
        Index         int
}

/**
        Clone returns a deep copy of the TransactionInput.

        Returns:
                TransactionInput: A deep copy of the TransactionInput.
*/
func (tx TransactionInput) Clone() TransactionInput <span class="cov8" title="1">{
        return TransactionInput{
                TransactionId: tx.TransactionId,
                Index:         tx.Index,
        }
}</span>

/**
        EqualTo checks if the TransactionInput is equal to another TransactionInput.

        Params:
                other TransactionInput: The TransactionInput to compare.

        Returns:
                bool: True if the TransactionInput is equal to the other TransactionInput, false otherwise.
*/
func (tx TransactionInput) EqualTo(other TransactionInput) bool <span class="cov8" title="1">{
        return bytes.Equal(tx.TransactionId, other.TransactionId) &amp;&amp; tx.Index == other.Index
}</span>

/**
        LessThan checks if the TransacctionInput is less than
        another TransactionInput based on index.

        Params:
                other TransactionInput: The TransactionInput to compare.

        Returns:
                bool: True if the TransactionInput is less than the other TransactionInput, false otherwise.
*/
func (tx TransactionInput) LessThan(other TransactionInput) bool <span class="cov8" title="1">{
        return tx.Index &lt; other.Index
}</span>

/**
        String returns a string representationof the TransactionInput
        in the format "transaction_id.index".
*/
func (tx TransactionInput) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(tx.TransactionId) + "." + strconv.Itoa(tx.Index)
}</span>

// func (tx TransactionInput) Hash() string {
//         final := append(tx.TransactionId[:], tx.Index)
//         blake_2b, _ := blake2b.New(TRANSACTION_HASH_SIZE, final)
//         KeyHash := blake_2b.Sum(make([]byte, 0))
//         return string(KeyHash)
// }
</pre>
		
		<pre class="file" id="file20" style="display: none">package TransactionOutput

import (
        "encoding/hex"
        "fmt"
        "reflect"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Value"

        "github.com/fxamacker/cbor/v2"
)

type TransactionOutputAlonzo struct {
        Address   Address.Address         `cbor:"0,keyasint"`
        Amount    Value.AlonzoValue       `cbor:"1,keyasint"`
        Datum     *PlutusData.DatumOption `cbor:"2,keyasint,omitempty"`
        ScriptRef *PlutusData.ScriptRef   `cbor:"3,keyasint,omitempty"`
}

/*
*

        Clone returns a dep copy of the TransactionOutputAlonzo.

        Returns:
                TransactionOutputAlonzo: A deep copy of the TransactionOutputAlonzo.
*/
func (t TransactionOutputAlonzo) Clone() TransactionOutputAlonzo <span class="cov8" title="1">{
        return TransactionOutputAlonzo{
                Address: t.Address,
                Amount:  t.Amount.Clone(),
                Datum:   t.Datum,
        }
}</span>

/*
*

        String returns a string representation of the TransactionOutputAlonzo,
        which includes the address and amount indicator.

        Returns:
                string: The string representation of TransactionOutputAlonzo.
*/
func (txo TransactionOutputAlonzo) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s Datum :%v", txo.Address.String(), txo.Amount.ToValue().String(), txo.Datum)
}</span>

type TransactionOutputShelley struct {
        Address   Address.Address
        Amount    Value.Value
        DatumHash serialization.DatumHash
        HasDatum  bool
}

/*
*

        Clone returns a deep copy of the TransactionOutputShelley.

        Returns:
                TransactionOutputShelley: A deep copy of the TransactionOutputShelley.
*/
func (t TransactionOutputShelley) Clone() TransactionOutputShelley <span class="cov8" title="1">{
        return TransactionOutputShelley{
                Address:   t.Address,
                Amount:    t.Amount.Clone(),
                DatumHash: t.DatumHash,
                HasDatum:  t.HasDatum,
        }
}</span>

/*
*

        String returns a string representation of the TransactionOutputShelley,
        which includes the address, amount and datum information in hexadecimal format.

        Returns:
                string: The string representation of TransactionOutputShelley.
*/
func (txo TransactionOutputShelley) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s DATUM: %s", fmt.Sprint(txo.Address), txo.Amount, hex.EncodeToString(txo.DatumHash.Payload[:]))
}</span>

type TxOWithDatum struct {
        _         struct{} `cbor:",toarray"`
        Address   Address.Address
        Amount    Value.Value
        DatumHash []byte
}
type TxOWithoutDatum struct {
        _       struct{} `cbor:",toarray"`
        Address Address.Address
        Amount  Value.Value
}

/*
*

        UnmarshalCBOR deserializes a CBOR-encoded byte slice into a TransactionOutputShelley,
        which determines whether the output has DATUM information and decodes accordingly.

        Params:
                value ([]byte): A CBOR-encoded byte slice representing the TransactionOutputShelley.

        Returns:
                error: An error if deserialization fails.
*/
func (txo *TransactionOutputShelley) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var x []interface{}
        _ = cbor.Unmarshal(value, &amp;x)
        if len(x) == 3 </span><span class="cov8" title="1">{
                val := new(TxOWithDatum)
                err := cbor.Unmarshal(value, &amp;val)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">txo.HasDatum = true
                txo.Address = val.Address
                txo.Amount = val.Amount
                if len(val.DatumHash) &gt; 0 </span><span class="cov8" title="1">{

                        dthash := serialization.DatumHash{Payload: val.DatumHash}
                        txo.DatumHash = dthash

                }</span>
        } else<span class="cov8" title="1"> {
                val := new(TxOWithoutDatum)
                err := cbor.Unmarshal(value, &amp;val)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">txo.HasDatum = false
                txo.Address = val.Address
                txo.Amount = val.Amount</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

                MarshalCBOR serializes the TransactionOutputShelley into a CBOR-encoded byte slice,
                which is based on the DATUM information.

                Returns:
                          []byte: A CBOR-encoded byte slice representing the TransactionOutputShelley.
                           error: An error if serialization fails.
*/
func (txo *TransactionOutputShelley) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if txo.HasDatum </span><span class="cov8" title="1">{
                val := new(TxOWithDatum)
                val.DatumHash = txo.DatumHash.Payload[:]
                val.Address = txo.Address
                val.Amount = txo.Amount
                return cbor.Marshal(val)
        }</span> else<span class="cov8" title="1"> {
                val := new(TxOWithoutDatum)
                val.Address = txo.Address
                val.Amount = txo.Amount
                return cbor.Marshal(val)
        }</span>
}

// TODO
type TransactionOutput struct {
        PostAlonzo   TransactionOutputAlonzo
        PreAlonzo    TransactionOutputShelley
        IsPostAlonzo bool
}

/*
*

        Clone creates a deep copy of the TransactionOutput.

        Returns:
                TransactionOutput: A deep copy of the TransactionOutput.
*/
func (to TransactionOutput) Clone() TransactionOutput <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return TransactionOutput{
                        IsPostAlonzo: to.IsPostAlonzo,
                        PostAlonzo:   to.PostAlonzo.Clone(),
                }
        }</span> else<span class="cov8" title="1"> {
                return TransactionOutput{
                        IsPostAlonzo: to.IsPostAlonzo,
                        PreAlonzo:    to.PreAlonzo.Clone(),
                }
        }</span>

}

/*
*

        EqualTo checks if the current TransactionOutput is equal to another one.

        Params:
                other (TransactionOutput): The other TransactionOutput to compare.

        Returns:
                bool: True if the TransactionOutputs are equal, false otherwise.
*/
func (to *TransactionOutput) EqualTo(other TransactionOutput) bool <span class="cov8" title="1">{
        if to.IsPostAlonzo != other.IsPostAlonzo </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if to.IsPostAlonzo </span><span class="cov8" title="1">{
                coinEquality := to.PostAlonzo.Amount.Coin == other.PostAlonzo.Amount.Coin
                assetEquality := to.PostAlonzo.Amount.ToValue().Equal(other.PostAlonzo.Amount.ToValue())
                datumEquality := reflect.DeepEqual(to.PostAlonzo.Datum, other.PostAlonzo.Datum)
                return coinEquality &amp;&amp; assetEquality &amp;&amp; datumEquality
        }</span> else<span class="cov8" title="1"> {
                coinEquality := to.PreAlonzo.Amount.Coin == other.PreAlonzo.Amount.Coin
                assetEquality := to.PreAlonzo.Amount.Equal(other.PreAlonzo.Amount)
                datumEquality := reflect.DeepEqual(to.PreAlonzo.DatumHash, other.PreAlonzo.DatumHash)
                return coinEquality &amp;&amp; assetEquality &amp;&amp; datumEquality
        }</span>
}

/*
*

        GetAmount retrieves the value of the TransactionOutput as a Value object.

        Returns:
                Value.Value: The value of the TransactionOutput as a Value object.
*/
func (to *TransactionOutput) GetAmount() Value.Value <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return to.PostAlonzo.Amount.ToValue()
        }</span> else<span class="cov8" title="1"> {
                return to.PreAlonzo.Amount
        }</span>
}

/*
*

        SimpleTransactionOutput creates a simple TransactionOutput with a given address and value.

        Params:
                address (Address.Address): The recipinet address.
                value (Value.value): The value to send.

        Returns:
                TransactionOutput: A simple TransactionOutput.
*/
func SimpleTransactionOutput(address Address.Address, value Value.Value) TransactionOutput <span class="cov8" title="1">{
        return TransactionOutput{
                IsPostAlonzo: false,
                PreAlonzo: TransactionOutputShelley{
                        Address:  address,
                        Amount:   value,
                        HasDatum: false,
                },
        }
}</span>

/*
*

        SetDatum sets the Datum of the TransactionOutput.
        If it is a post Alonzo, it sets the Datum directly,
        otherwise it sets the DatumHash.

        Params:
                datum (*PlutusData.PlutusData): The Datum to set.
*/
func (to *TransactionOutput) SetDatum(datum *PlutusData.PlutusData) <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                l := PlutusData.DatumOptionInline(datum)
                to.PostAlonzo.Datum = &amp;l
        }</span> else<span class="cov8" title="1"> {
                dataHash, err := PlutusData.PlutusDataHash(datum)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">to.PreAlonzo.DatumHash = dataHash
                to.PreAlonzo.HasDatum = true</span>
        }
}

/*
*

        GetAddress retrieves the recipient address of the TransactionOutput.

        Returns:
                Address.Address: The recipient address.
*/
func (to *TransactionOutput) GetAddress() Address.Address <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return to.PostAlonzo.Address
        }</span> else<span class="cov8" title="1"> {
                return to.PreAlonzo.Address
        }</span>
}

/*
*

        GetAddressPointer retrieves a pointer to the recipient address of the TransactionOutput.

        Returns:
                *Address.Address: A pointer to the recipient address.
*/
func (to *TransactionOutput) GetAddressPointer() *Address.Address <span class="cov0" title="0">{
        if to.IsPostAlonzo </span><span class="cov0" title="0">{
                return &amp;to.PostAlonzo.Address
        }</span> else<span class="cov0" title="0"> {
                return &amp;to.PreAlonzo.Address
        }</span>
}

/*
*

        GetDatumHash retrieves, if available, the DatumHash of the TransactionOutput.

        Returns:
                *serialization.DatumHash: The DatumHash of the TransictionOutput or nil.
*/
func (to *TransactionOutput) GetDatumHash() *serialization.DatumHash <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return &amp;to.PreAlonzo.DatumHash
        }</span>
}

/*
*

        GetAddressPointer retrieves, if available, the Datum of the TransactionOutput.

        Returns:
                *PlutusData.PlutusData: The Datum of the TransictionOutput or an empty PlutusData.PlutusData.
*/
func (to *TransactionOutput) GetDatum() *PlutusData.PlutusData <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                switch d := to.PostAlonzo.Datum; d.DatumType </span>{
                case PlutusData.DatumTypeHash:<span class="cov0" title="0">
                        return nil</span>
                case PlutusData.DatumTypeInline:<span class="cov8" title="1">
                        return d.Inline</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }
        } else<span class="cov8" title="1"> {
                return nil
        }</span>
}

func (to *TransactionOutput) GetDatumOption() *PlutusData.DatumOption <span class="cov0" title="0">{
        if to.IsPostAlonzo </span><span class="cov0" title="0">{
                return to.PostAlonzo.Datum
        }</span> else<span class="cov0" title="0"> {
                d := PlutusData.DatumOptionHash(to.PreAlonzo.DatumHash.Payload)
                return &amp;d
        }</span>
}

/**
GetScriptRef retrieves, if available, the ScriptRef of the TransactionOutput.

Returns:
        *PlutusData.PlutusData: The ScriptRef of the TransictionOutput or an empty PlutusData.ScriptRef.
*/

func (to *TransactionOutput) GetScriptRef() *PlutusData.ScriptRef <span class="cov0" title="0">{
        if to.IsPostAlonzo </span><span class="cov0" title="0">{
                return to.PostAlonzo.ScriptRef
        }</span> else<span class="cov0" title="0"> {
                return new(PlutusData.ScriptRef)
        }</span>
}

/*
*

        GetValue retrieves the value of the TransactionOutput as a value object.

        Returns:
                Value.Value: The value of the TransactionOutput as a Value object.
*/
func (to *TransactionOutput) GetValue() Value.Value <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return to.PostAlonzo.Amount.ToValue()
        }</span> else<span class="cov8" title="1"> {
                return to.PreAlonzo.Amount
        }</span>
}

/*
*

        Lovelace retireves the amount in Lovelace of the TransactionOutput.

        Returns:
                int64: The amount in Lovelace.
*/
func (to *TransactionOutput) Lovelace() int64 <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                if to.PostAlonzo.Amount.HasAssets </span><span class="cov8" title="1">{
                        return to.PostAlonzo.Amount.Am.Coin
                }</span> else<span class="cov8" title="1"> {
                        return to.PostAlonzo.Amount.Coin
                }</span>
        } else<span class="cov8" title="1"> {
                if to.PreAlonzo.Amount.HasAssets </span><span class="cov8" title="1">{
                        return to.PreAlonzo.Amount.Am.Coin
                }</span> else<span class="cov8" title="1"> {
                        return to.PreAlonzo.Amount.Coin
                }</span>
        }
}

/*
*

        String returns a string representation of the TransactionOutput.

        Returns:
                string: A string representation of the TransactionOutput.
*/
func (txo TransactionOutput) String() string <span class="cov8" title="1">{
        if txo.IsPostAlonzo </span><span class="cov8" title="1">{
                return fmt.Sprint(txo.PostAlonzo)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprint(txo.PreAlonzo)
        }</span>
}

/*
*

                UnmarshalCBOR deserializes a CBOR-encoded byte slice into a TransactionOutput,
                which determines the format of the output (pre- or post-Alonzo) and decodes accordingly.

                 Params:
                           value ([]byte): A CBOR-encoded byte slice representing the TransactionOutput.

                 Returns:
                           error: An error if deserialization fails.
*/
func (txo *TransactionOutput) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var x any
        _ = cbor.Unmarshal(value, &amp;x)
        if reflect.TypeOf(x).String() == "[]interface {}" </span><span class="cov8" title="1">{
                txo.IsPostAlonzo = false
                err := cbor.Unmarshal(value, &amp;txo.PreAlonzo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        } else<span class="cov8" title="1"> {
                txo.IsPostAlonzo = true
                err := cbor.Unmarshal(value, &amp;txo.PostAlonzo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

                MarshalCBOR serializes the TransactionOutput into a CBOR-encoded byte slice, which
                encodes the output based on whether it is pre- or post- Alonzo.

                Returns:
                           []byte: A CBOR-encoded byte slice representing the TransactionOutput.
                           error: An error if serialization fails.
*/
func (txo *TransactionOutput) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if txo.IsPostAlonzo </span><span class="cov8" title="1">{
                return cbor.Marshal(txo.PostAlonzo)
        }</span> else<span class="cov8" title="1"> {
                return cbor.Marshal(txo.PreAlonzo)
        }</span>
}

/*
*

                SetAmount sets the amount of the TransactionOutput. In case of a post-Alonzo output,
                the amount is set directly, otherwise the amount is set.

                 Params:
                          amount Value.Value: The amount to set.
*/
func (txo *TransactionOutput) SetAmount(amount Value.Value) <span class="cov8" title="1">{
        if txo.IsPostAlonzo </span><span class="cov8" title="1">{
                txo.PostAlonzo.Amount = amount.ToAlonzoValue()
        }</span> else<span class="cov8" title="1"> {
                txo.PreAlonzo.Amount = amount
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package TransactionWitnessSet

import (
        "github.com/Salvionied/apollo/serialization/NativeScript"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/VerificationKeyWitness"
        "github.com/fxamacker/cbor/v2"
)

type normaltws struct {
        VkeyWitnesses      []VerificationKeyWitness.VerificationKeyWitness `cbor:"0,keyasint,omitempty"`
        NativeScripts      []NativeScript.NativeScript                     `cbor:"1,keyasint,omitempty"`
        BootstrapWitnesses []any                                           `cbor:"2,keyasint,omitempty"`
        PlutusV1Script     []PlutusData.PlutusV1Script                     `cbor:"3,keyasint,omitempty"`
        PlutusV2Script     []PlutusData.PlutusV2Script                     `cbor:"6,keyasint,omitempty"`
        PlutusData         *PlutusData.PlutusIndefArray                    `cbor:"4,keyasint,omitempty"`
        Redeemer           []Redeemer.Redeemer                             `cbor:"5,keyasint,omitempty"`
}
type TransactionWitnessSet struct {
        VkeyWitnesses      []VerificationKeyWitness.VerificationKeyWitness `cbor:"0,keyasint,omitempty"`
        NativeScripts      []NativeScript.NativeScript                     `cbor:"1,keyasint,omitempty"`
        BootstrapWitnesses []any                                           `cbor:"2,keyasint,omitempty"`
        PlutusV1Script     []PlutusData.PlutusV1Script                     `cbor:"3,keyasint,omitempty"`
        PlutusV2Script     []PlutusData.PlutusV2Script                     `cbor:"6,keyasint,omitempty"`
        PlutusData         PlutusData.PlutusIndefArray                     `cbor:"4,keyasint,omitempty"`
        Redeemer           []Redeemer.Redeemer                             `cbor:"5,keyasint,omitempty"`
}

type WithRedeemerNoScripts struct {
        VkeyWitnesses      []VerificationKeyWitness.VerificationKeyWitness `cbor:"0,keyasint,omitempty"`
        NativeScripts      []NativeScript.NativeScript                     `cbor:"1,keyasint,omitempty"`
        BootstrapWitnesses []any                                           `cbor:"2,keyasint,omitempty"`
        PlutusV1Script     []PlutusData.PlutusV1Script                     `cbor:"3,keyasint,"`
        PlutusV2Script     []PlutusData.PlutusV2Script                     `cbor:"6,keyasint,omitempty"`
        PlutusData         *PlutusData.PlutusIndefArray                    `cbor:"4,keyasint,omitempty"`
        Redeemer           []Redeemer.Redeemer                             `cbor:"5,keyasint,omitempty"`
}

/*
*

        MarshalCBOR serializes the TransactionWitnessSet to a CBOR byte slice.

        Returns:
                []byte: The CBOR-serialized TransactionWitnessSet.
                error: An error if serialization fails.
*/
func (tws *TransactionWitnessSet) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if len(tws.PlutusV1Script) == 0 &amp;&amp; len(tws.Redeemer) &gt; 0 &amp;&amp; len(tws.PlutusData) == 0 </span><span class="cov0" title="0">{
                return cbor.Marshal(WithRedeemerNoScripts{
                        VkeyWitnesses:      tws.VkeyWitnesses,
                        NativeScripts:      tws.NativeScripts,
                        BootstrapWitnesses: tws.BootstrapWitnesses,
                        PlutusV1Script:     tws.PlutusV1Script,
                        PlutusV2Script:     tws.PlutusV2Script,
                        PlutusData:         nil,
                        Redeemer:           tws.Redeemer,
                })
        }</span>
        <span class="cov8" title="1">return cbor.Marshal(normaltws{
                VkeyWitnesses:      tws.VkeyWitnesses,
                NativeScripts:      tws.NativeScripts,
                BootstrapWitnesses: tws.BootstrapWitnesses,
                PlutusV1Script:     tws.PlutusV1Script,
                PlutusV2Script:     tws.PlutusV2Script,
                PlutusData:         &amp;tws.PlutusData,
                Redeemer:           tws.Redeemer,
        })</span>

}
</pre>
		
		<pre class="file" id="file22" style="display: none">package UTxO

import (
        "encoding/hex"
        "fmt"

        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
)

type Container[T any] interface {
        EqualTo(other T) bool
}

type UTxO struct {
        _      struct{} `cbor:",toarray"`
        Input  TransactionInput.TransactionInput
        Output TransactionOutput.TransactionOutput
}

/*
*

        GetKey returns a unique key for the UTxO through its
        transaction ID and index.

        Returns:
                string: The unique key representing the UTxO.
*/
func (u UTxO) GetKey() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", hex.EncodeToString(u.Input.TransactionId), u.Input.Index)
}</span>

/*
*

        Clone creates a deep copy of the UTxO instance.

        Returns:
                UTxO: A new UTxO instance.
*/
func (u UTxO) Clone() UTxO <span class="cov8" title="1">{
        return UTxO{
                Input:  u.Input.Clone(),
                Output: u.Output.Clone(),
        }
}</span>

/*
*

        EqualTo checks if the UTxO is equal to another object.

        Params:
                other interface{}: The object to compare with the UTxO.

        Returns:
                bool: True if the UTxO is equal to the proved object, false otherwise.
*/
func (u UTxO) EqualTo(other any) bool <span class="cov8" title="1">{
        ok, other := other.(UTxO)
        return u.Input.EqualTo(ok.Input) &amp;&amp; u.Output.EqualTo(ok.Output)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package Value

import (
        "errors"
        "fmt"
        "reflect"

        "github.com/Salvionied/apollo/serialization/Amount"
        "github.com/Salvionied/apollo/serialization/MultiAsset"

        "github.com/fxamacker/cbor/v2"
)

type Value struct {
        Am        Amount.Amount
        Coin      int64
        HasAssets bool
}

type AlonzoValue struct {
        Am        Amount.AlonzoAmount
        Coin      int64
        HasAssets bool
}

/*
*

        UnmarshalCBOR deserializes CBOr-encoded data into an AlonzoValue.

        Params:
                value ([]byte): The CBOR-encoded data to be deserialized.

        Returns:
                error: An error if deserialization fails.
*/
func (val *AlonzoValue) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var rec any
        _ = cbor.Unmarshal(value, &amp;rec)
        if reflect.ValueOf(rec).Type().String() == "uint64" </span><span class="cov8" title="1">{
                ok, _ := rec.(uint64)
                val.Coin = int64(ok)
        }</span> else<span class="cov8" title="1"> {
                am := Amount.Amount{}
                err := cbor.Unmarshal(value, &amp;am)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">val.Am = am.ToAlonzo()
                val.HasAssets = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

        MarshalCBOR serializes the AlonzoValue into an CBOr-encoded data.

        Returns:
                []byte: The CBOR-encoded data.
                error: An error if deserialization fails.
*/
func (alVal *AlonzoValue) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if alVal.HasAssets </span><span class="cov8" title="1">{
                if alVal.Am.Coin &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid coin value")
                }</span>
                <span class="cov8" title="1">em, _ := cbor.CanonicalEncOptions().EncMode()
                return em.Marshal(alVal.Am)</span>
        } else<span class="cov8" title="1"> {
                if alVal.Coin &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid coin value")
                }</span>
                <span class="cov8" title="1">return cbor.Marshal(alVal.Coin)</span>
        }
}

/*
*

        Clone creates a copy of the AlonzoValue, including its assets.

        Returns:
                AlonzoValue: A copy of the AlonzoValue.
*/
func (alVal AlonzoValue) Clone() AlonzoValue <span class="cov8" title="1">{
        if alVal.HasAssets </span><span class="cov8" title="1">{
                return AlonzoValue{
                        Am:        alVal.Am.Clone(),
                        Coin:      alVal.Coin,
                        HasAssets: alVal.HasAssets,
                }
        }</span>
        <span class="cov8" title="1">return AlonzoValue{
                Coin:      alVal.Coin,
                HasAssets: alVal.HasAssets,
        }</span>
}

/*
*

        ToAlonzoValue converts a Value object to an AlonzoValue, preserving its attributes.

        Returns:
                AlonzoValue: An AlonzoValue converted from a Value object.
*/
func (val Value) ToAlonzoValue() AlonzoValue <span class="cov8" title="1">{
        return AlonzoValue{
                Am:        val.Am.ToAlonzo(),
                Coin:      val.Coin,
                HasAssets: val.HasAssets,
        }
}</span>

/*
*

        ToValue converts an AlonzoValue to a Value object, preserving its attributes.

        Returns:
                Value: A Value object converted from an AlonzoValue.
*/
func (alVal AlonzoValue) ToValue() Value <span class="cov8" title="1">{
        return Value{
                Am:        alVal.Am.ToShelley(),
                Coin:      alVal.Coin,
                HasAssets: alVal.HasAssets,
        }
}</span>

/*
*

        RemoveZeroAssets removes assets with zero values from a Value.

        Returns:
                Value: A Value without zero assets.
*/
func (val Value) RemoveZeroAssets() Value <span class="cov8" title="1">{
        res := val.Clone()
        if res.HasAssets </span><span class="cov8" title="1">{
                res.Am = res.Am.RemoveZeroAssets()
        }</span>
        <span class="cov8" title="1">return res</span>
}

/*
*

        Clone creates a copy of the Value, including its assets.

        Returns:
                Value: A copy of the Value.
*/
func (val Value) Clone() Value <span class="cov8" title="1">{
        if val.HasAssets </span><span class="cov8" title="1">{
                return Value{
                        Am:        val.Am.Clone(),
                        Coin:      val.Coin,
                        HasAssets: val.HasAssets,
                }
        }</span> else<span class="cov8" title="1"> {
                return Value{
                        Coin:      val.Coin,
                        HasAssets: val.HasAssets,
                }
        }</span>
}

/*
*

        AddAssets adds MultiAsset assets to a Value.

        Params:
                other (MultiAsset.MultiAsset[int64]): the MultiAssets assets to be added.
*/
func (val *Value) AddAssets(other MultiAsset.MultiAsset[int64]) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.HasAssets = true
                val.Am.Coin = val.Coin
                val.Coin = 0
                val.Am.Value = other
        }</span> else<span class="cov8" title="1"> {
                val.Am.Value = val.Am.Value.Add(other)
        }</span>
}

/*
*

        SimpleValue creates a Value object with a specified coin value and a MultiAssets.

        Params:
                coin (int64): The coin value.
                assets (MultiAsset.MultiAsset[int64]): the assets.

        Returns:
                Value: A Value object.
*/
func SimpleValue(coin int64, assets MultiAsset.MultiAsset[int64]) Value <span class="cov8" title="1">{
        if len(assets) == 0 </span><span class="cov8" title="1">{
                return Value{
                        Coin: coin,
                }
        }</span>
        <span class="cov8" title="1">return Value{
                Am: Amount.Amount{
                        Coin:  coin,
                        Value: assets,
                },
                HasAssets: true,
        }</span>
}

/*
*

        SubLovelace subtracts a specified amount of Lovelace (coin) from the Value.
        In case that there aren't any assets, then it subtracts from the Coin field,
        otherwise from the AlonzoAmount's Coin field.

        Params:
                amount (int64): The amount of Lovelace (coin) to subtract.
*/
func (val *Value) SubLovelace(amount int64) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.Coin -= amount
        }</span> else<span class="cov8" title="1"> {
                val.Am.Coin -= amount
        }</span>
}

/*
*

        AddLovelace adds a specified amount of Lovelace (coin) from the Value.
        In case that there aren't any assets, then it adds to the Coin field,
        otherwise to the AlonzoAmount's Coin field.

        Params:
                amount (int64): The amount of Lovelace (coin) to add.
*/
func (val *Value) AddLovelace(amount int64) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.Coin += amount
        }</span> else<span class="cov8" title="1"> {
                val.Am.Coin += amount
        }</span>
}

/*
*

        SetLovelace sets a specified amount of Lovelace (coin) in the Value.
        In case that there aren't any assets, then it sets the Coin field,
        otherwise it sets the AlonzoAmount's Coin field.

        Params:
                amount (int64): The amount of Lovelace (coin) to set.
*/
func (val *Value) SetLovelace(amount int64) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.Coin = amount
        }</span> else<span class="cov8" title="1"> {
                val.Am.Coin = amount
        }</span>
}

/*
*

        SetMultiAsset sets the MultiAsset in the Value.

        Params:
                amount (MultiAsset.MultiAsset[int64]): The MultiAsset assets to set.
*/
func (val *Value) SetMultiAsset(amount MultiAsset.MultiAsset[int64]) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.HasAssets = true
                val.Am.Coin = val.Coin
                val.Coin = 0
        }</span>
        <span class="cov8" title="1">val.Am.Value = amount</span>
}

/*
*

        GetCoin returns the amount of Lovelace (coin) in the Value.

        Returns:
                int64: The amount of Lovelace (coin).
*/
func (val Value) GetCoin() int64 <span class="cov8" title="1">{
        if val.HasAssets </span><span class="cov8" title="1">{
                return val.Am.Coin
        }</span>
        <span class="cov8" title="1">return val.Coin</span>
}

/*
*

        GetAssets returns the MultiAsset assets in the Value.

        Returns:
                MultiAsset.MultiAsset[int64]: The MultiAsset assets.
*/
func (val Value) GetAssets() MultiAsset.MultiAsset[int64] <span class="cov8" title="1">{
        if val.HasAssets </span><span class="cov8" title="1">{
                return val.Am.Value
        }</span>
        <span class="cov8" title="1">return nil</span>
}

/*
*

        Add function adds another Value to the current Value.

        Params:
                other (Value): The Value to add to the current Value.

        Returns:
                Value: The resulting Value after the addition.
*/
func (val Value) Add(other Value) Value <span class="cov8" title="1">{
        res := val.Clone()
        if other.HasAssets </span><span class="cov8" title="1">{
                if res.HasAssets </span><span class="cov8" title="1">{
                        res.Am = res.Am.Add(other.Am)
                }</span> else<span class="cov0" title="0"> {
                        res.Am.Coin = res.Coin + other.Am.Coin
                        res.HasAssets = true
                        res.Am.Value = other.Am.Value
                }</span>
        } else<span class="cov8" title="1"> {
                if res.HasAssets </span><span class="cov8" title="1">{
                        res.Am.Coin += other.Coin
                }</span> else<span class="cov8" title="1"> {
                        res.Coin += other.Coin
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

/*
*

        Sub function subtracts another Value to the current Value.

        Params:
                other (Value): The Value to subtract to the current Value.

        Returns:
                Value: The resulting Value after the subtraction.
*/
func (val Value) Sub(other Value) Value <span class="cov8" title="1">{
        res := val.Clone()
        if other.HasAssets </span><span class="cov8" title="1">{
                if res.HasAssets </span><span class="cov8" title="1">{
                        res.Am = res.Am.Sub(other.Am)
                }</span> else<span class="cov0" title="0"> {
                        res.Coin -= other.Am.Coin
                }</span>
        } else<span class="cov8" title="1"> {
                if res.HasAssets </span><span class="cov8" title="1">{
                        res.Am.Coin -= other.Coin
                }</span> else<span class="cov8" title="1"> {
                        res.Coin -= other.Coin
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

/*
*

        Less checks if the current Value is less than another Value.

        Params:
                other (Value): The Value to compare.

        Returns:
                bool: True if the current value is less than the other Value, false otherwise.
*/
func (val Value) Less(other Value) bool <span class="cov8" title="1">{
        return val.GetCoin() &lt;= other.GetCoin() &amp;&amp; val.GetAssets().Less(other.GetAssets())
}</span>

/*
*

        Equal checks if the current Value is equal to another Value.

        Params:
                other (Value): The Value to compare.

        Returns:
                bool: True if the current value is equal to the other Value, false otherwise.
*/
func (val Value) Equal(other Value) bool <span class="cov8" title="1">{
        if val.HasAssets != other.HasAssets </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if val.HasAssets </span><span class="cov8" title="1">{
                return val.Coin == other.Coin &amp;&amp; val.Am.Equal(other.Am)
        }</span> else<span class="cov8" title="1"> {
                return val.Coin == other.Coin
        }</span>
}

/*
*

        LessOrEqual checks if the current Value is less than or equal to another Value.

        Params:
                other (Value): The Value to compare.

        Returns:
                bool: True if the current value is less than or equal to the other Value, false otherwise.
*/
func (val Value) LessOrEqual(other Value) bool <span class="cov8" title="1">{
        return val.Equal(other) || val.Less(other)
}</span>

/*
*

        Greater checks if the current Value is greater than another Value.

        Params:
                other (Value): The Value to compare.

        Returns:
                bool: True if the current value is greater than the other Value, false otherwise.
*/
func (val Value) Greater(other Value) bool <span class="cov8" title="1">{
        return val.GetCoin() &gt;= other.GetCoin() &amp;&amp; val.GetAssets().Greater(other.GetAssets())

}</span>

/*
*

        GreaterOrEqual checks if the current Value is greater than or equal to another Value.

        Params:
                other (Value): The Value to compare.

        Returns:
                bool: True if the current value is greater than or equal to the other Value, false otherwise.
*/
func (val Value) GreaterOrEqual(other Value) bool <span class="cov8" title="1">{
        return val.Greater(other) || val.Equal(other)
}</span>

/*
*

        String reutnrs a string representation of teh Value.

        Returns:
                string: The string representation of the Value.
*/
func (val Value) String() string <span class="cov0" title="0">{
        if val.HasAssets </span><span class="cov0" title="0">{
                return fmt.Sprint(val.Am)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprint(val.Coin)
        }</span>
}

/*
*

                UnmarshalCBOR unmarshals a CBOR-encoded byte slice into the Value,
                which decoed either a uint64 inot the Coin field or a CBOR-encoded Amount
                into the AlonzoAmount field.

                Params:
                    value ([]byte): The CBOR-encoded byte slice to unmarshal.

                  Returns:
                    error: An error if unmarshaling fails.
*/
func (val *Value) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var rec any
        _ = cbor.Unmarshal(value, &amp;rec)
        if reflect.ValueOf(rec).Type().String() == "uint64" </span><span class="cov8" title="1">{
                ok, _ := rec.(uint64)
                val.Coin = int64(ok)
        }</span> else<span class="cov0" title="0"> {
                am := Amount.Amount{}
                err := cbor.Unmarshal(value, &amp;am)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">val.Am = am
                val.HasAssets = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

        MarshalCBOR marshals the Value into a CBOR-encoded byte slice.
        If the Value has assets, then it encodes the AlonzoAmount using CBOR,
        otherwise it encodes the Coin field directly.

        Returns:
                []byte: The CBOR-encoded byte slice.
                error: An error if marshaling fails.
*/
func (val *Value) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if val.HasAssets </span><span class="cov8" title="1">{
                if val.Am.Coin &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid coin value")
                }</span>
                <span class="cov8" title="1">em, _ := cbor.CanonicalEncOptions().EncMode()
                return em.Marshal(val.Am)</span>
        } else<span class="cov8" title="1"> {
                if val.Coin &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid coin value")
                }</span>
                <span class="cov8" title="1">return cbor.Marshal(val.Coin)</span>
        }
}

/*
*

                 PureLovelaceValue creates a Value with only a specified amount
                of Lovelace (coin) and no assets.

                Params:
                        coin (int64): The amount of Lovelace (coin) to set in the Value.

                Returns:
                        Value: The Value with the specified amount of Lovelace and no assets.
*/
func PureLovelaceValue(coin int64) Value <span class="cov8" title="1">{
        return Value{Coin: coin, HasAssets: false}
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
